// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/bugs"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/codecov"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/predicate"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/prowjobs"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/prowsuites"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/pullrequests"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/repository"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/teams"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/workflows"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBugs         = "Bugs"
	TypeCodeCov      = "CodeCov"
	TypeProwJobs     = "ProwJobs"
	TypeProwSuites   = "ProwSuites"
	TypePullRequests = "PullRequests"
	TypeRepository   = "Repository"
	TypeTeams        = "Teams"
	TypeWorkflows    = "Workflows"
)

// BugsMutation represents an operation that mutates the Bugs nodes in the graph.
type BugsMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	jira_key           *string
	created_at         *time.Time
	updated_at         *time.Time
	resolved_at        *time.Time
	resolved           *bool
	priority           *string
	resolution_time    *float64
	addresolution_time *float64
	status             *string
	summary            *string
	url                *string
	clearedFields      map[string]struct{}
	bugs               *uuid.UUID
	clearedbugs        bool
	done               bool
	oldValue           func(context.Context) (*Bugs, error)
	predicates         []predicate.Bugs
}

var _ ent.Mutation = (*BugsMutation)(nil)

// bugsOption allows management of the mutation configuration using functional options.
type bugsOption func(*BugsMutation)

// newBugsMutation creates new mutation for the Bugs entity.
func newBugsMutation(c config, op Op, opts ...bugsOption) *BugsMutation {
	m := &BugsMutation{
		config:        c,
		op:            op,
		typ:           TypeBugs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBugsID sets the ID field of the mutation.
func withBugsID(id uuid.UUID) bugsOption {
	return func(m *BugsMutation) {
		var (
			err   error
			once  sync.Once
			value *Bugs
		)
		m.oldValue = func(ctx context.Context) (*Bugs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bugs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBugs sets the old Bugs of the mutation.
func withBugs(node *Bugs) bugsOption {
	return func(m *BugsMutation) {
		m.oldValue = func(context.Context) (*Bugs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BugsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BugsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bugs entities.
func (m *BugsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BugsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BugsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Bugs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJiraKey sets the "jira_key" field.
func (m *BugsMutation) SetJiraKey(s string) {
	m.jira_key = &s
}

// JiraKey returns the value of the "jira_key" field in the mutation.
func (m *BugsMutation) JiraKey() (r string, exists bool) {
	v := m.jira_key
	if v == nil {
		return
	}
	return *v, true
}

// OldJiraKey returns the old "jira_key" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldJiraKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJiraKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJiraKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJiraKey: %w", err)
	}
	return oldValue.JiraKey, nil
}

// ResetJiraKey resets all changes to the "jira_key" field.
func (m *BugsMutation) ResetJiraKey() {
	m.jira_key = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BugsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BugsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BugsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BugsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BugsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BugsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetResolvedAt sets the "resolved_at" field.
func (m *BugsMutation) SetResolvedAt(t time.Time) {
	m.resolved_at = &t
}

// ResolvedAt returns the value of the "resolved_at" field in the mutation.
func (m *BugsMutation) ResolvedAt() (r time.Time, exists bool) {
	v := m.resolved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedAt returns the old "resolved_at" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldResolvedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedAt: %w", err)
	}
	return oldValue.ResolvedAt, nil
}

// ResetResolvedAt resets all changes to the "resolved_at" field.
func (m *BugsMutation) ResetResolvedAt() {
	m.resolved_at = nil
}

// SetResolved sets the "resolved" field.
func (m *BugsMutation) SetResolved(b bool) {
	m.resolved = &b
}

// Resolved returns the value of the "resolved" field in the mutation.
func (m *BugsMutation) Resolved() (r bool, exists bool) {
	v := m.resolved
	if v == nil {
		return
	}
	return *v, true
}

// OldResolved returns the old "resolved" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldResolved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolved: %w", err)
	}
	return oldValue.Resolved, nil
}

// ResetResolved resets all changes to the "resolved" field.
func (m *BugsMutation) ResetResolved() {
	m.resolved = nil
}

// SetPriority sets the "priority" field.
func (m *BugsMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *BugsMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *BugsMutation) ResetPriority() {
	m.priority = nil
}

// SetResolutionTime sets the "resolution_time" field.
func (m *BugsMutation) SetResolutionTime(f float64) {
	m.resolution_time = &f
	m.addresolution_time = nil
}

// ResolutionTime returns the value of the "resolution_time" field in the mutation.
func (m *BugsMutation) ResolutionTime() (r float64, exists bool) {
	v := m.resolution_time
	if v == nil {
		return
	}
	return *v, true
}

// OldResolutionTime returns the old "resolution_time" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldResolutionTime(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolutionTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolutionTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolutionTime: %w", err)
	}
	return oldValue.ResolutionTime, nil
}

// AddResolutionTime adds f to the "resolution_time" field.
func (m *BugsMutation) AddResolutionTime(f float64) {
	if m.addresolution_time != nil {
		*m.addresolution_time += f
	} else {
		m.addresolution_time = &f
	}
}

// AddedResolutionTime returns the value that was added to the "resolution_time" field in this mutation.
func (m *BugsMutation) AddedResolutionTime() (r float64, exists bool) {
	v := m.addresolution_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetResolutionTime resets all changes to the "resolution_time" field.
func (m *BugsMutation) ResetResolutionTime() {
	m.resolution_time = nil
	m.addresolution_time = nil
}

// SetStatus sets the "status" field.
func (m *BugsMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *BugsMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BugsMutation) ResetStatus() {
	m.status = nil
}

// SetSummary sets the "summary" field.
func (m *BugsMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *BugsMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ResetSummary resets all changes to the "summary" field.
func (m *BugsMutation) ResetSummary() {
	m.summary = nil
}

// SetURL sets the "url" field.
func (m *BugsMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *BugsMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *BugsMutation) ResetURL() {
	m.url = nil
}

// SetBugsID sets the "bugs" edge to the Teams entity by id.
func (m *BugsMutation) SetBugsID(id uuid.UUID) {
	m.bugs = &id
}

// ClearBugs clears the "bugs" edge to the Teams entity.
func (m *BugsMutation) ClearBugs() {
	m.clearedbugs = true
}

// BugsCleared reports if the "bugs" edge to the Teams entity was cleared.
func (m *BugsMutation) BugsCleared() bool {
	return m.clearedbugs
}

// BugsID returns the "bugs" edge ID in the mutation.
func (m *BugsMutation) BugsID() (id uuid.UUID, exists bool) {
	if m.bugs != nil {
		return *m.bugs, true
	}
	return
}

// BugsIDs returns the "bugs" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BugsID instead. It exists only for internal usage by the builders.
func (m *BugsMutation) BugsIDs() (ids []uuid.UUID) {
	if id := m.bugs; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBugs resets all changes to the "bugs" edge.
func (m *BugsMutation) ResetBugs() {
	m.bugs = nil
	m.clearedbugs = false
}

// Where appends a list predicates to the BugsMutation builder.
func (m *BugsMutation) Where(ps ...predicate.Bugs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BugsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BugsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Bugs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BugsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BugsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Bugs).
func (m *BugsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BugsMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.jira_key != nil {
		fields = append(fields, bugs.FieldJiraKey)
	}
	if m.created_at != nil {
		fields = append(fields, bugs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bugs.FieldUpdatedAt)
	}
	if m.resolved_at != nil {
		fields = append(fields, bugs.FieldResolvedAt)
	}
	if m.resolved != nil {
		fields = append(fields, bugs.FieldResolved)
	}
	if m.priority != nil {
		fields = append(fields, bugs.FieldPriority)
	}
	if m.resolution_time != nil {
		fields = append(fields, bugs.FieldResolutionTime)
	}
	if m.status != nil {
		fields = append(fields, bugs.FieldStatus)
	}
	if m.summary != nil {
		fields = append(fields, bugs.FieldSummary)
	}
	if m.url != nil {
		fields = append(fields, bugs.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BugsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bugs.FieldJiraKey:
		return m.JiraKey()
	case bugs.FieldCreatedAt:
		return m.CreatedAt()
	case bugs.FieldUpdatedAt:
		return m.UpdatedAt()
	case bugs.FieldResolvedAt:
		return m.ResolvedAt()
	case bugs.FieldResolved:
		return m.Resolved()
	case bugs.FieldPriority:
		return m.Priority()
	case bugs.FieldResolutionTime:
		return m.ResolutionTime()
	case bugs.FieldStatus:
		return m.Status()
	case bugs.FieldSummary:
		return m.Summary()
	case bugs.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BugsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bugs.FieldJiraKey:
		return m.OldJiraKey(ctx)
	case bugs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bugs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case bugs.FieldResolvedAt:
		return m.OldResolvedAt(ctx)
	case bugs.FieldResolved:
		return m.OldResolved(ctx)
	case bugs.FieldPriority:
		return m.OldPriority(ctx)
	case bugs.FieldResolutionTime:
		return m.OldResolutionTime(ctx)
	case bugs.FieldStatus:
		return m.OldStatus(ctx)
	case bugs.FieldSummary:
		return m.OldSummary(ctx)
	case bugs.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown Bugs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BugsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bugs.FieldJiraKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJiraKey(v)
		return nil
	case bugs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bugs.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case bugs.FieldResolvedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedAt(v)
		return nil
	case bugs.FieldResolved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolved(v)
		return nil
	case bugs.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case bugs.FieldResolutionTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolutionTime(v)
		return nil
	case bugs.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case bugs.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case bugs.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown Bugs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BugsMutation) AddedFields() []string {
	var fields []string
	if m.addresolution_time != nil {
		fields = append(fields, bugs.FieldResolutionTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BugsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bugs.FieldResolutionTime:
		return m.AddedResolutionTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BugsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bugs.FieldResolutionTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResolutionTime(v)
		return nil
	}
	return fmt.Errorf("unknown Bugs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BugsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BugsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BugsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bugs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BugsMutation) ResetField(name string) error {
	switch name {
	case bugs.FieldJiraKey:
		m.ResetJiraKey()
		return nil
	case bugs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bugs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case bugs.FieldResolvedAt:
		m.ResetResolvedAt()
		return nil
	case bugs.FieldResolved:
		m.ResetResolved()
		return nil
	case bugs.FieldPriority:
		m.ResetPriority()
		return nil
	case bugs.FieldResolutionTime:
		m.ResetResolutionTime()
		return nil
	case bugs.FieldStatus:
		m.ResetStatus()
		return nil
	case bugs.FieldSummary:
		m.ResetSummary()
		return nil
	case bugs.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown Bugs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BugsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bugs != nil {
		edges = append(edges, bugs.EdgeBugs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BugsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bugs.EdgeBugs:
		if id := m.bugs; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BugsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BugsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BugsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbugs {
		edges = append(edges, bugs.EdgeBugs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BugsMutation) EdgeCleared(name string) bool {
	switch name {
	case bugs.EdgeBugs:
		return m.clearedbugs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BugsMutation) ClearEdge(name string) error {
	switch name {
	case bugs.EdgeBugs:
		m.ClearBugs()
		return nil
	}
	return fmt.Errorf("unknown Bugs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BugsMutation) ResetEdge(name string) error {
	switch name {
	case bugs.EdgeBugs:
		m.ResetBugs()
		return nil
	}
	return fmt.Errorf("unknown Bugs edge %s", name)
}

// CodeCovMutation represents an operation that mutates the CodeCov nodes in the graph.
type CodeCovMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	repository_name             *string
	git_organization            *string
	coverage_percentage         *float64
	addcoverage_percentage      *float64
	average_retests_to_merge    *float64
	addaverage_retests_to_merge *float64
	clearedFields               map[string]struct{}
	codecov                     *string
	clearedcodecov              bool
	done                        bool
	oldValue                    func(context.Context) (*CodeCov, error)
	predicates                  []predicate.CodeCov
}

var _ ent.Mutation = (*CodeCovMutation)(nil)

// codecovOption allows management of the mutation configuration using functional options.
type codecovOption func(*CodeCovMutation)

// newCodeCovMutation creates new mutation for the CodeCov entity.
func newCodeCovMutation(c config, op Op, opts ...codecovOption) *CodeCovMutation {
	m := &CodeCovMutation{
		config:        c,
		op:            op,
		typ:           TypeCodeCov,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodeCovID sets the ID field of the mutation.
func withCodeCovID(id uuid.UUID) codecovOption {
	return func(m *CodeCovMutation) {
		var (
			err   error
			once  sync.Once
			value *CodeCov
		)
		m.oldValue = func(ctx context.Context) (*CodeCov, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodeCov.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodeCov sets the old CodeCov of the mutation.
func withCodeCov(node *CodeCov) codecovOption {
	return func(m *CodeCovMutation) {
		m.oldValue = func(context.Context) (*CodeCov, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodeCovMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodeCovMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CodeCov entities.
func (m *CodeCovMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodeCovMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CodeCovMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CodeCov.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRepositoryName sets the "repository_name" field.
func (m *CodeCovMutation) SetRepositoryName(s string) {
	m.repository_name = &s
}

// RepositoryName returns the value of the "repository_name" field in the mutation.
func (m *CodeCovMutation) RepositoryName() (r string, exists bool) {
	v := m.repository_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRepositoryName returns the old "repository_name" field's value of the CodeCov entity.
// If the CodeCov object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeCovMutation) OldRepositoryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepositoryName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepositoryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepositoryName: %w", err)
	}
	return oldValue.RepositoryName, nil
}

// ResetRepositoryName resets all changes to the "repository_name" field.
func (m *CodeCovMutation) ResetRepositoryName() {
	m.repository_name = nil
}

// SetGitOrganization sets the "git_organization" field.
func (m *CodeCovMutation) SetGitOrganization(s string) {
	m.git_organization = &s
}

// GitOrganization returns the value of the "git_organization" field in the mutation.
func (m *CodeCovMutation) GitOrganization() (r string, exists bool) {
	v := m.git_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldGitOrganization returns the old "git_organization" field's value of the CodeCov entity.
// If the CodeCov object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeCovMutation) OldGitOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitOrganization: %w", err)
	}
	return oldValue.GitOrganization, nil
}

// ResetGitOrganization resets all changes to the "git_organization" field.
func (m *CodeCovMutation) ResetGitOrganization() {
	m.git_organization = nil
}

// SetCoveragePercentage sets the "coverage_percentage" field.
func (m *CodeCovMutation) SetCoveragePercentage(f float64) {
	m.coverage_percentage = &f
	m.addcoverage_percentage = nil
}

// CoveragePercentage returns the value of the "coverage_percentage" field in the mutation.
func (m *CodeCovMutation) CoveragePercentage() (r float64, exists bool) {
	v := m.coverage_percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldCoveragePercentage returns the old "coverage_percentage" field's value of the CodeCov entity.
// If the CodeCov object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeCovMutation) OldCoveragePercentage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoveragePercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoveragePercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoveragePercentage: %w", err)
	}
	return oldValue.CoveragePercentage, nil
}

// AddCoveragePercentage adds f to the "coverage_percentage" field.
func (m *CodeCovMutation) AddCoveragePercentage(f float64) {
	if m.addcoverage_percentage != nil {
		*m.addcoverage_percentage += f
	} else {
		m.addcoverage_percentage = &f
	}
}

// AddedCoveragePercentage returns the value that was added to the "coverage_percentage" field in this mutation.
func (m *CodeCovMutation) AddedCoveragePercentage() (r float64, exists bool) {
	v := m.addcoverage_percentage
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoveragePercentage resets all changes to the "coverage_percentage" field.
func (m *CodeCovMutation) ResetCoveragePercentage() {
	m.coverage_percentage = nil
	m.addcoverage_percentage = nil
}

// SetAverageRetestsToMerge sets the "average_retests_to_merge" field.
func (m *CodeCovMutation) SetAverageRetestsToMerge(f float64) {
	m.average_retests_to_merge = &f
	m.addaverage_retests_to_merge = nil
}

// AverageRetestsToMerge returns the value of the "average_retests_to_merge" field in the mutation.
func (m *CodeCovMutation) AverageRetestsToMerge() (r float64, exists bool) {
	v := m.average_retests_to_merge
	if v == nil {
		return
	}
	return *v, true
}

// OldAverageRetestsToMerge returns the old "average_retests_to_merge" field's value of the CodeCov entity.
// If the CodeCov object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeCovMutation) OldAverageRetestsToMerge(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAverageRetestsToMerge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAverageRetestsToMerge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAverageRetestsToMerge: %w", err)
	}
	return oldValue.AverageRetestsToMerge, nil
}

// AddAverageRetestsToMerge adds f to the "average_retests_to_merge" field.
func (m *CodeCovMutation) AddAverageRetestsToMerge(f float64) {
	if m.addaverage_retests_to_merge != nil {
		*m.addaverage_retests_to_merge += f
	} else {
		m.addaverage_retests_to_merge = &f
	}
}

// AddedAverageRetestsToMerge returns the value that was added to the "average_retests_to_merge" field in this mutation.
func (m *CodeCovMutation) AddedAverageRetestsToMerge() (r float64, exists bool) {
	v := m.addaverage_retests_to_merge
	if v == nil {
		return
	}
	return *v, true
}

// ResetAverageRetestsToMerge resets all changes to the "average_retests_to_merge" field.
func (m *CodeCovMutation) ResetAverageRetestsToMerge() {
	m.average_retests_to_merge = nil
	m.addaverage_retests_to_merge = nil
}

// SetCodecovID sets the "codecov" edge to the Repository entity by id.
func (m *CodeCovMutation) SetCodecovID(id string) {
	m.codecov = &id
}

// ClearCodecov clears the "codecov" edge to the Repository entity.
func (m *CodeCovMutation) ClearCodecov() {
	m.clearedcodecov = true
}

// CodecovCleared reports if the "codecov" edge to the Repository entity was cleared.
func (m *CodeCovMutation) CodecovCleared() bool {
	return m.clearedcodecov
}

// CodecovID returns the "codecov" edge ID in the mutation.
func (m *CodeCovMutation) CodecovID() (id string, exists bool) {
	if m.codecov != nil {
		return *m.codecov, true
	}
	return
}

// CodecovIDs returns the "codecov" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CodecovID instead. It exists only for internal usage by the builders.
func (m *CodeCovMutation) CodecovIDs() (ids []string) {
	if id := m.codecov; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCodecov resets all changes to the "codecov" edge.
func (m *CodeCovMutation) ResetCodecov() {
	m.codecov = nil
	m.clearedcodecov = false
}

// Where appends a list predicates to the CodeCovMutation builder.
func (m *CodeCovMutation) Where(ps ...predicate.CodeCov) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CodeCovMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CodeCovMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CodeCov, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CodeCovMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CodeCovMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CodeCov).
func (m *CodeCovMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodeCovMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.repository_name != nil {
		fields = append(fields, codecov.FieldRepositoryName)
	}
	if m.git_organization != nil {
		fields = append(fields, codecov.FieldGitOrganization)
	}
	if m.coverage_percentage != nil {
		fields = append(fields, codecov.FieldCoveragePercentage)
	}
	if m.average_retests_to_merge != nil {
		fields = append(fields, codecov.FieldAverageRetestsToMerge)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodeCovMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codecov.FieldRepositoryName:
		return m.RepositoryName()
	case codecov.FieldGitOrganization:
		return m.GitOrganization()
	case codecov.FieldCoveragePercentage:
		return m.CoveragePercentage()
	case codecov.FieldAverageRetestsToMerge:
		return m.AverageRetestsToMerge()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodeCovMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codecov.FieldRepositoryName:
		return m.OldRepositoryName(ctx)
	case codecov.FieldGitOrganization:
		return m.OldGitOrganization(ctx)
	case codecov.FieldCoveragePercentage:
		return m.OldCoveragePercentage(ctx)
	case codecov.FieldAverageRetestsToMerge:
		return m.OldAverageRetestsToMerge(ctx)
	}
	return nil, fmt.Errorf("unknown CodeCov field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodeCovMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codecov.FieldRepositoryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepositoryName(v)
		return nil
	case codecov.FieldGitOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitOrganization(v)
		return nil
	case codecov.FieldCoveragePercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoveragePercentage(v)
		return nil
	case codecov.FieldAverageRetestsToMerge:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAverageRetestsToMerge(v)
		return nil
	}
	return fmt.Errorf("unknown CodeCov field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodeCovMutation) AddedFields() []string {
	var fields []string
	if m.addcoverage_percentage != nil {
		fields = append(fields, codecov.FieldCoveragePercentage)
	}
	if m.addaverage_retests_to_merge != nil {
		fields = append(fields, codecov.FieldAverageRetestsToMerge)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodeCovMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case codecov.FieldCoveragePercentage:
		return m.AddedCoveragePercentage()
	case codecov.FieldAverageRetestsToMerge:
		return m.AddedAverageRetestsToMerge()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodeCovMutation) AddField(name string, value ent.Value) error {
	switch name {
	case codecov.FieldCoveragePercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoveragePercentage(v)
		return nil
	case codecov.FieldAverageRetestsToMerge:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAverageRetestsToMerge(v)
		return nil
	}
	return fmt.Errorf("unknown CodeCov numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodeCovMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodeCovMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodeCovMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CodeCov nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodeCovMutation) ResetField(name string) error {
	switch name {
	case codecov.FieldRepositoryName:
		m.ResetRepositoryName()
		return nil
	case codecov.FieldGitOrganization:
		m.ResetGitOrganization()
		return nil
	case codecov.FieldCoveragePercentage:
		m.ResetCoveragePercentage()
		return nil
	case codecov.FieldAverageRetestsToMerge:
		m.ResetAverageRetestsToMerge()
		return nil
	}
	return fmt.Errorf("unknown CodeCov field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodeCovMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.codecov != nil {
		edges = append(edges, codecov.EdgeCodecov)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodeCovMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codecov.EdgeCodecov:
		if id := m.codecov; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodeCovMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodeCovMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodeCovMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcodecov {
		edges = append(edges, codecov.EdgeCodecov)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodeCovMutation) EdgeCleared(name string) bool {
	switch name {
	case codecov.EdgeCodecov:
		return m.clearedcodecov
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodeCovMutation) ClearEdge(name string) error {
	switch name {
	case codecov.EdgeCodecov:
		m.ClearCodecov()
		return nil
	}
	return fmt.Errorf("unknown CodeCov unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodeCovMutation) ResetEdge(name string) error {
	switch name {
	case codecov.EdgeCodecov:
		m.ResetCodecov()
		return nil
	}
	return fmt.Errorf("unknown CodeCov edge %s", name)
}

// ProwJobsMutation represents an operation that mutates the ProwJobs nodes in the graph.
type ProwJobsMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	job_id                   *string
	created_at               *time.Time
	duration                 *float64
	addduration              *float64
	tests_count              *int64
	addtests_count           *int64
	failed_count             *int64
	addfailed_count          *int64
	skipped_count            *int64
	addskipped_count         *int64
	job_name                 *string
	job_type                 *string
	state                    *string
	job_url                  *string
	ci_failed                *int16
	addci_failed             *int16
	e2e_failed_test_messages *string
	suites_xml_url           *string
	clearedFields            map[string]struct{}
	prow_jobs                *string
	clearedprow_jobs         bool
	done                     bool
	oldValue                 func(context.Context) (*ProwJobs, error)
	predicates               []predicate.ProwJobs
}

var _ ent.Mutation = (*ProwJobsMutation)(nil)

// prowjobsOption allows management of the mutation configuration using functional options.
type prowjobsOption func(*ProwJobsMutation)

// newProwJobsMutation creates new mutation for the ProwJobs entity.
func newProwJobsMutation(c config, op Op, opts ...prowjobsOption) *ProwJobsMutation {
	m := &ProwJobsMutation{
		config:        c,
		op:            op,
		typ:           TypeProwJobs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProwJobsID sets the ID field of the mutation.
func withProwJobsID(id int) prowjobsOption {
	return func(m *ProwJobsMutation) {
		var (
			err   error
			once  sync.Once
			value *ProwJobs
		)
		m.oldValue = func(ctx context.Context) (*ProwJobs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProwJobs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProwJobs sets the old ProwJobs of the mutation.
func withProwJobs(node *ProwJobs) prowjobsOption {
	return func(m *ProwJobsMutation) {
		m.oldValue = func(context.Context) (*ProwJobs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProwJobsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProwJobsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProwJobsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProwJobsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProwJobs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJobID sets the "job_id" field.
func (m *ProwJobsMutation) SetJobID(s string) {
	m.job_id = &s
}

// JobID returns the value of the "job_id" field in the mutation.
func (m *ProwJobsMutation) JobID() (r string, exists bool) {
	v := m.job_id
	if v == nil {
		return
	}
	return *v, true
}

// OldJobID returns the old "job_id" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldJobID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobID: %w", err)
	}
	return oldValue.JobID, nil
}

// ResetJobID resets all changes to the "job_id" field.
func (m *ProwJobsMutation) ResetJobID() {
	m.job_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProwJobsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProwJobsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProwJobsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDuration sets the "duration" field.
func (m *ProwJobsMutation) SetDuration(f float64) {
	m.duration = &f
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *ProwJobsMutation) Duration() (r float64, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldDuration(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds f to the "duration" field.
func (m *ProwJobsMutation) AddDuration(f float64) {
	if m.addduration != nil {
		*m.addduration += f
	} else {
		m.addduration = &f
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *ProwJobsMutation) AddedDuration() (r float64, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *ProwJobsMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetTestsCount sets the "tests_count" field.
func (m *ProwJobsMutation) SetTestsCount(i int64) {
	m.tests_count = &i
	m.addtests_count = nil
}

// TestsCount returns the value of the "tests_count" field in the mutation.
func (m *ProwJobsMutation) TestsCount() (r int64, exists bool) {
	v := m.tests_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTestsCount returns the old "tests_count" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldTestsCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestsCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestsCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestsCount: %w", err)
	}
	return oldValue.TestsCount, nil
}

// AddTestsCount adds i to the "tests_count" field.
func (m *ProwJobsMutation) AddTestsCount(i int64) {
	if m.addtests_count != nil {
		*m.addtests_count += i
	} else {
		m.addtests_count = &i
	}
}

// AddedTestsCount returns the value that was added to the "tests_count" field in this mutation.
func (m *ProwJobsMutation) AddedTestsCount() (r int64, exists bool) {
	v := m.addtests_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTestsCount resets all changes to the "tests_count" field.
func (m *ProwJobsMutation) ResetTestsCount() {
	m.tests_count = nil
	m.addtests_count = nil
}

// SetFailedCount sets the "failed_count" field.
func (m *ProwJobsMutation) SetFailedCount(i int64) {
	m.failed_count = &i
	m.addfailed_count = nil
}

// FailedCount returns the value of the "failed_count" field in the mutation.
func (m *ProwJobsMutation) FailedCount() (r int64, exists bool) {
	v := m.failed_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFailedCount returns the old "failed_count" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldFailedCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailedCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailedCount: %w", err)
	}
	return oldValue.FailedCount, nil
}

// AddFailedCount adds i to the "failed_count" field.
func (m *ProwJobsMutation) AddFailedCount(i int64) {
	if m.addfailed_count != nil {
		*m.addfailed_count += i
	} else {
		m.addfailed_count = &i
	}
}

// AddedFailedCount returns the value that was added to the "failed_count" field in this mutation.
func (m *ProwJobsMutation) AddedFailedCount() (r int64, exists bool) {
	v := m.addfailed_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFailedCount resets all changes to the "failed_count" field.
func (m *ProwJobsMutation) ResetFailedCount() {
	m.failed_count = nil
	m.addfailed_count = nil
}

// SetSkippedCount sets the "skipped_count" field.
func (m *ProwJobsMutation) SetSkippedCount(i int64) {
	m.skipped_count = &i
	m.addskipped_count = nil
}

// SkippedCount returns the value of the "skipped_count" field in the mutation.
func (m *ProwJobsMutation) SkippedCount() (r int64, exists bool) {
	v := m.skipped_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSkippedCount returns the old "skipped_count" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldSkippedCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkippedCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkippedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkippedCount: %w", err)
	}
	return oldValue.SkippedCount, nil
}

// AddSkippedCount adds i to the "skipped_count" field.
func (m *ProwJobsMutation) AddSkippedCount(i int64) {
	if m.addskipped_count != nil {
		*m.addskipped_count += i
	} else {
		m.addskipped_count = &i
	}
}

// AddedSkippedCount returns the value that was added to the "skipped_count" field in this mutation.
func (m *ProwJobsMutation) AddedSkippedCount() (r int64, exists bool) {
	v := m.addskipped_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSkippedCount resets all changes to the "skipped_count" field.
func (m *ProwJobsMutation) ResetSkippedCount() {
	m.skipped_count = nil
	m.addskipped_count = nil
}

// SetJobName sets the "job_name" field.
func (m *ProwJobsMutation) SetJobName(s string) {
	m.job_name = &s
}

// JobName returns the value of the "job_name" field in the mutation.
func (m *ProwJobsMutation) JobName() (r string, exists bool) {
	v := m.job_name
	if v == nil {
		return
	}
	return *v, true
}

// OldJobName returns the old "job_name" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldJobName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobName: %w", err)
	}
	return oldValue.JobName, nil
}

// ResetJobName resets all changes to the "job_name" field.
func (m *ProwJobsMutation) ResetJobName() {
	m.job_name = nil
}

// SetJobType sets the "job_type" field.
func (m *ProwJobsMutation) SetJobType(s string) {
	m.job_type = &s
}

// JobType returns the value of the "job_type" field in the mutation.
func (m *ProwJobsMutation) JobType() (r string, exists bool) {
	v := m.job_type
	if v == nil {
		return
	}
	return *v, true
}

// OldJobType returns the old "job_type" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldJobType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobType: %w", err)
	}
	return oldValue.JobType, nil
}

// ResetJobType resets all changes to the "job_type" field.
func (m *ProwJobsMutation) ResetJobType() {
	m.job_type = nil
}

// SetState sets the "state" field.
func (m *ProwJobsMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *ProwJobsMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *ProwJobsMutation) ResetState() {
	m.state = nil
}

// SetJobURL sets the "job_url" field.
func (m *ProwJobsMutation) SetJobURL(s string) {
	m.job_url = &s
}

// JobURL returns the value of the "job_url" field in the mutation.
func (m *ProwJobsMutation) JobURL() (r string, exists bool) {
	v := m.job_url
	if v == nil {
		return
	}
	return *v, true
}

// OldJobURL returns the old "job_url" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldJobURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobURL: %w", err)
	}
	return oldValue.JobURL, nil
}

// ResetJobURL resets all changes to the "job_url" field.
func (m *ProwJobsMutation) ResetJobURL() {
	m.job_url = nil
}

// SetCiFailed sets the "ci_failed" field.
func (m *ProwJobsMutation) SetCiFailed(i int16) {
	m.ci_failed = &i
	m.addci_failed = nil
}

// CiFailed returns the value of the "ci_failed" field in the mutation.
func (m *ProwJobsMutation) CiFailed() (r int16, exists bool) {
	v := m.ci_failed
	if v == nil {
		return
	}
	return *v, true
}

// OldCiFailed returns the old "ci_failed" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldCiFailed(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCiFailed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCiFailed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCiFailed: %w", err)
	}
	return oldValue.CiFailed, nil
}

// AddCiFailed adds i to the "ci_failed" field.
func (m *ProwJobsMutation) AddCiFailed(i int16) {
	if m.addci_failed != nil {
		*m.addci_failed += i
	} else {
		m.addci_failed = &i
	}
}

// AddedCiFailed returns the value that was added to the "ci_failed" field in this mutation.
func (m *ProwJobsMutation) AddedCiFailed() (r int16, exists bool) {
	v := m.addci_failed
	if v == nil {
		return
	}
	return *v, true
}

// ResetCiFailed resets all changes to the "ci_failed" field.
func (m *ProwJobsMutation) ResetCiFailed() {
	m.ci_failed = nil
	m.addci_failed = nil
}

// SetE2eFailedTestMessages sets the "e2e_failed_test_messages" field.
func (m *ProwJobsMutation) SetE2eFailedTestMessages(s string) {
	m.e2e_failed_test_messages = &s
}

// E2eFailedTestMessages returns the value of the "e2e_failed_test_messages" field in the mutation.
func (m *ProwJobsMutation) E2eFailedTestMessages() (r string, exists bool) {
	v := m.e2e_failed_test_messages
	if v == nil {
		return
	}
	return *v, true
}

// OldE2eFailedTestMessages returns the old "e2e_failed_test_messages" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldE2eFailedTestMessages(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldE2eFailedTestMessages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldE2eFailedTestMessages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldE2eFailedTestMessages: %w", err)
	}
	return oldValue.E2eFailedTestMessages, nil
}

// ResetE2eFailedTestMessages resets all changes to the "e2e_failed_test_messages" field.
func (m *ProwJobsMutation) ResetE2eFailedTestMessages() {
	m.e2e_failed_test_messages = nil
}

// SetSuitesXMLURL sets the "suites_xml_url" field.
func (m *ProwJobsMutation) SetSuitesXMLURL(s string) {
	m.suites_xml_url = &s
}

// SuitesXMLURL returns the value of the "suites_xml_url" field in the mutation.
func (m *ProwJobsMutation) SuitesXMLURL() (r string, exists bool) {
	v := m.suites_xml_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSuitesXMLURL returns the old "suites_xml_url" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldSuitesXMLURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuitesXMLURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuitesXMLURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuitesXMLURL: %w", err)
	}
	return oldValue.SuitesXMLURL, nil
}

// ResetSuitesXMLURL resets all changes to the "suites_xml_url" field.
func (m *ProwJobsMutation) ResetSuitesXMLURL() {
	m.suites_xml_url = nil
}

// SetProwJobsID sets the "prow_jobs" edge to the Repository entity by id.
func (m *ProwJobsMutation) SetProwJobsID(id string) {
	m.prow_jobs = &id
}

// ClearProwJobs clears the "prow_jobs" edge to the Repository entity.
func (m *ProwJobsMutation) ClearProwJobs() {
	m.clearedprow_jobs = true
}

// ProwJobsCleared reports if the "prow_jobs" edge to the Repository entity was cleared.
func (m *ProwJobsMutation) ProwJobsCleared() bool {
	return m.clearedprow_jobs
}

// ProwJobsID returns the "prow_jobs" edge ID in the mutation.
func (m *ProwJobsMutation) ProwJobsID() (id string, exists bool) {
	if m.prow_jobs != nil {
		return *m.prow_jobs, true
	}
	return
}

// ProwJobsIDs returns the "prow_jobs" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProwJobsID instead. It exists only for internal usage by the builders.
func (m *ProwJobsMutation) ProwJobsIDs() (ids []string) {
	if id := m.prow_jobs; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProwJobs resets all changes to the "prow_jobs" edge.
func (m *ProwJobsMutation) ResetProwJobs() {
	m.prow_jobs = nil
	m.clearedprow_jobs = false
}

// Where appends a list predicates to the ProwJobsMutation builder.
func (m *ProwJobsMutation) Where(ps ...predicate.ProwJobs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProwJobsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProwJobsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProwJobs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProwJobsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProwJobsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProwJobs).
func (m *ProwJobsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProwJobsMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.job_id != nil {
		fields = append(fields, prowjobs.FieldJobID)
	}
	if m.created_at != nil {
		fields = append(fields, prowjobs.FieldCreatedAt)
	}
	if m.duration != nil {
		fields = append(fields, prowjobs.FieldDuration)
	}
	if m.tests_count != nil {
		fields = append(fields, prowjobs.FieldTestsCount)
	}
	if m.failed_count != nil {
		fields = append(fields, prowjobs.FieldFailedCount)
	}
	if m.skipped_count != nil {
		fields = append(fields, prowjobs.FieldSkippedCount)
	}
	if m.job_name != nil {
		fields = append(fields, prowjobs.FieldJobName)
	}
	if m.job_type != nil {
		fields = append(fields, prowjobs.FieldJobType)
	}
	if m.state != nil {
		fields = append(fields, prowjobs.FieldState)
	}
	if m.job_url != nil {
		fields = append(fields, prowjobs.FieldJobURL)
	}
	if m.ci_failed != nil {
		fields = append(fields, prowjobs.FieldCiFailed)
	}
	if m.e2e_failed_test_messages != nil {
		fields = append(fields, prowjobs.FieldE2eFailedTestMessages)
	}
	if m.suites_xml_url != nil {
		fields = append(fields, prowjobs.FieldSuitesXMLURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProwJobsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prowjobs.FieldJobID:
		return m.JobID()
	case prowjobs.FieldCreatedAt:
		return m.CreatedAt()
	case prowjobs.FieldDuration:
		return m.Duration()
	case prowjobs.FieldTestsCount:
		return m.TestsCount()
	case prowjobs.FieldFailedCount:
		return m.FailedCount()
	case prowjobs.FieldSkippedCount:
		return m.SkippedCount()
	case prowjobs.FieldJobName:
		return m.JobName()
	case prowjobs.FieldJobType:
		return m.JobType()
	case prowjobs.FieldState:
		return m.State()
	case prowjobs.FieldJobURL:
		return m.JobURL()
	case prowjobs.FieldCiFailed:
		return m.CiFailed()
	case prowjobs.FieldE2eFailedTestMessages:
		return m.E2eFailedTestMessages()
	case prowjobs.FieldSuitesXMLURL:
		return m.SuitesXMLURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProwJobsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prowjobs.FieldJobID:
		return m.OldJobID(ctx)
	case prowjobs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case prowjobs.FieldDuration:
		return m.OldDuration(ctx)
	case prowjobs.FieldTestsCount:
		return m.OldTestsCount(ctx)
	case prowjobs.FieldFailedCount:
		return m.OldFailedCount(ctx)
	case prowjobs.FieldSkippedCount:
		return m.OldSkippedCount(ctx)
	case prowjobs.FieldJobName:
		return m.OldJobName(ctx)
	case prowjobs.FieldJobType:
		return m.OldJobType(ctx)
	case prowjobs.FieldState:
		return m.OldState(ctx)
	case prowjobs.FieldJobURL:
		return m.OldJobURL(ctx)
	case prowjobs.FieldCiFailed:
		return m.OldCiFailed(ctx)
	case prowjobs.FieldE2eFailedTestMessages:
		return m.OldE2eFailedTestMessages(ctx)
	case prowjobs.FieldSuitesXMLURL:
		return m.OldSuitesXMLURL(ctx)
	}
	return nil, fmt.Errorf("unknown ProwJobs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProwJobsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prowjobs.FieldJobID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobID(v)
		return nil
	case prowjobs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case prowjobs.FieldDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case prowjobs.FieldTestsCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestsCount(v)
		return nil
	case prowjobs.FieldFailedCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailedCount(v)
		return nil
	case prowjobs.FieldSkippedCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkippedCount(v)
		return nil
	case prowjobs.FieldJobName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobName(v)
		return nil
	case prowjobs.FieldJobType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobType(v)
		return nil
	case prowjobs.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case prowjobs.FieldJobURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobURL(v)
		return nil
	case prowjobs.FieldCiFailed:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCiFailed(v)
		return nil
	case prowjobs.FieldE2eFailedTestMessages:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetE2eFailedTestMessages(v)
		return nil
	case prowjobs.FieldSuitesXMLURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuitesXMLURL(v)
		return nil
	}
	return fmt.Errorf("unknown ProwJobs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProwJobsMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, prowjobs.FieldDuration)
	}
	if m.addtests_count != nil {
		fields = append(fields, prowjobs.FieldTestsCount)
	}
	if m.addfailed_count != nil {
		fields = append(fields, prowjobs.FieldFailedCount)
	}
	if m.addskipped_count != nil {
		fields = append(fields, prowjobs.FieldSkippedCount)
	}
	if m.addci_failed != nil {
		fields = append(fields, prowjobs.FieldCiFailed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProwJobsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case prowjobs.FieldDuration:
		return m.AddedDuration()
	case prowjobs.FieldTestsCount:
		return m.AddedTestsCount()
	case prowjobs.FieldFailedCount:
		return m.AddedFailedCount()
	case prowjobs.FieldSkippedCount:
		return m.AddedSkippedCount()
	case prowjobs.FieldCiFailed:
		return m.AddedCiFailed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProwJobsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case prowjobs.FieldDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case prowjobs.FieldTestsCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTestsCount(v)
		return nil
	case prowjobs.FieldFailedCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFailedCount(v)
		return nil
	case prowjobs.FieldSkippedCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSkippedCount(v)
		return nil
	case prowjobs.FieldCiFailed:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCiFailed(v)
		return nil
	}
	return fmt.Errorf("unknown ProwJobs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProwJobsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProwJobsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProwJobsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProwJobs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProwJobsMutation) ResetField(name string) error {
	switch name {
	case prowjobs.FieldJobID:
		m.ResetJobID()
		return nil
	case prowjobs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case prowjobs.FieldDuration:
		m.ResetDuration()
		return nil
	case prowjobs.FieldTestsCount:
		m.ResetTestsCount()
		return nil
	case prowjobs.FieldFailedCount:
		m.ResetFailedCount()
		return nil
	case prowjobs.FieldSkippedCount:
		m.ResetSkippedCount()
		return nil
	case prowjobs.FieldJobName:
		m.ResetJobName()
		return nil
	case prowjobs.FieldJobType:
		m.ResetJobType()
		return nil
	case prowjobs.FieldState:
		m.ResetState()
		return nil
	case prowjobs.FieldJobURL:
		m.ResetJobURL()
		return nil
	case prowjobs.FieldCiFailed:
		m.ResetCiFailed()
		return nil
	case prowjobs.FieldE2eFailedTestMessages:
		m.ResetE2eFailedTestMessages()
		return nil
	case prowjobs.FieldSuitesXMLURL:
		m.ResetSuitesXMLURL()
		return nil
	}
	return fmt.Errorf("unknown ProwJobs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProwJobsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.prow_jobs != nil {
		edges = append(edges, prowjobs.EdgeProwJobs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProwJobsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prowjobs.EdgeProwJobs:
		if id := m.prow_jobs; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProwJobsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProwJobsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProwJobsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprow_jobs {
		edges = append(edges, prowjobs.EdgeProwJobs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProwJobsMutation) EdgeCleared(name string) bool {
	switch name {
	case prowjobs.EdgeProwJobs:
		return m.clearedprow_jobs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProwJobsMutation) ClearEdge(name string) error {
	switch name {
	case prowjobs.EdgeProwJobs:
		m.ClearProwJobs()
		return nil
	}
	return fmt.Errorf("unknown ProwJobs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProwJobsMutation) ResetEdge(name string) error {
	switch name {
	case prowjobs.EdgeProwJobs:
		m.ResetProwJobs()
		return nil
	}
	return fmt.Errorf("unknown ProwJobs edge %s", name)
}

// ProwSuitesMutation represents an operation that mutates the ProwSuites nodes in the graph.
type ProwSuitesMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	job_id             *string
	name               *string
	status             *string
	time               *float64
	addtime            *float64
	clearedFields      map[string]struct{}
	prow_suites        *string
	clearedprow_suites bool
	done               bool
	oldValue           func(context.Context) (*ProwSuites, error)
	predicates         []predicate.ProwSuites
}

var _ ent.Mutation = (*ProwSuitesMutation)(nil)

// prowsuitesOption allows management of the mutation configuration using functional options.
type prowsuitesOption func(*ProwSuitesMutation)

// newProwSuitesMutation creates new mutation for the ProwSuites entity.
func newProwSuitesMutation(c config, op Op, opts ...prowsuitesOption) *ProwSuitesMutation {
	m := &ProwSuitesMutation{
		config:        c,
		op:            op,
		typ:           TypeProwSuites,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProwSuitesID sets the ID field of the mutation.
func withProwSuitesID(id int) prowsuitesOption {
	return func(m *ProwSuitesMutation) {
		var (
			err   error
			once  sync.Once
			value *ProwSuites
		)
		m.oldValue = func(ctx context.Context) (*ProwSuites, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProwSuites.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProwSuites sets the old ProwSuites of the mutation.
func withProwSuites(node *ProwSuites) prowsuitesOption {
	return func(m *ProwSuitesMutation) {
		m.oldValue = func(context.Context) (*ProwSuites, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProwSuitesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProwSuitesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProwSuitesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProwSuitesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProwSuites.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJobID sets the "job_id" field.
func (m *ProwSuitesMutation) SetJobID(s string) {
	m.job_id = &s
}

// JobID returns the value of the "job_id" field in the mutation.
func (m *ProwSuitesMutation) JobID() (r string, exists bool) {
	v := m.job_id
	if v == nil {
		return
	}
	return *v, true
}

// OldJobID returns the old "job_id" field's value of the ProwSuites entity.
// If the ProwSuites object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwSuitesMutation) OldJobID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobID: %w", err)
	}
	return oldValue.JobID, nil
}

// ResetJobID resets all changes to the "job_id" field.
func (m *ProwSuitesMutation) ResetJobID() {
	m.job_id = nil
}

// SetName sets the "name" field.
func (m *ProwSuitesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProwSuitesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProwSuites entity.
// If the ProwSuites object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwSuitesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProwSuitesMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *ProwSuitesMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ProwSuitesMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProwSuites entity.
// If the ProwSuites object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwSuitesMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProwSuitesMutation) ResetStatus() {
	m.status = nil
}

// SetTime sets the "time" field.
func (m *ProwSuitesMutation) SetTime(f float64) {
	m.time = &f
	m.addtime = nil
}

// Time returns the value of the "time" field in the mutation.
func (m *ProwSuitesMutation) Time() (r float64, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the ProwSuites entity.
// If the ProwSuites object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwSuitesMutation) OldTime(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// AddTime adds f to the "time" field.
func (m *ProwSuitesMutation) AddTime(f float64) {
	if m.addtime != nil {
		*m.addtime += f
	} else {
		m.addtime = &f
	}
}

// AddedTime returns the value that was added to the "time" field in this mutation.
func (m *ProwSuitesMutation) AddedTime() (r float64, exists bool) {
	v := m.addtime
	if v == nil {
		return
	}
	return *v, true
}

// ResetTime resets all changes to the "time" field.
func (m *ProwSuitesMutation) ResetTime() {
	m.time = nil
	m.addtime = nil
}

// SetProwSuitesID sets the "prow_suites" edge to the Repository entity by id.
func (m *ProwSuitesMutation) SetProwSuitesID(id string) {
	m.prow_suites = &id
}

// ClearProwSuites clears the "prow_suites" edge to the Repository entity.
func (m *ProwSuitesMutation) ClearProwSuites() {
	m.clearedprow_suites = true
}

// ProwSuitesCleared reports if the "prow_suites" edge to the Repository entity was cleared.
func (m *ProwSuitesMutation) ProwSuitesCleared() bool {
	return m.clearedprow_suites
}

// ProwSuitesID returns the "prow_suites" edge ID in the mutation.
func (m *ProwSuitesMutation) ProwSuitesID() (id string, exists bool) {
	if m.prow_suites != nil {
		return *m.prow_suites, true
	}
	return
}

// ProwSuitesIDs returns the "prow_suites" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProwSuitesID instead. It exists only for internal usage by the builders.
func (m *ProwSuitesMutation) ProwSuitesIDs() (ids []string) {
	if id := m.prow_suites; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProwSuites resets all changes to the "prow_suites" edge.
func (m *ProwSuitesMutation) ResetProwSuites() {
	m.prow_suites = nil
	m.clearedprow_suites = false
}

// Where appends a list predicates to the ProwSuitesMutation builder.
func (m *ProwSuitesMutation) Where(ps ...predicate.ProwSuites) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProwSuitesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProwSuitesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProwSuites, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProwSuitesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProwSuitesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProwSuites).
func (m *ProwSuitesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProwSuitesMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.job_id != nil {
		fields = append(fields, prowsuites.FieldJobID)
	}
	if m.name != nil {
		fields = append(fields, prowsuites.FieldName)
	}
	if m.status != nil {
		fields = append(fields, prowsuites.FieldStatus)
	}
	if m.time != nil {
		fields = append(fields, prowsuites.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProwSuitesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prowsuites.FieldJobID:
		return m.JobID()
	case prowsuites.FieldName:
		return m.Name()
	case prowsuites.FieldStatus:
		return m.Status()
	case prowsuites.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProwSuitesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prowsuites.FieldJobID:
		return m.OldJobID(ctx)
	case prowsuites.FieldName:
		return m.OldName(ctx)
	case prowsuites.FieldStatus:
		return m.OldStatus(ctx)
	case prowsuites.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown ProwSuites field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProwSuitesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prowsuites.FieldJobID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobID(v)
		return nil
	case prowsuites.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case prowsuites.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case prowsuites.FieldTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown ProwSuites field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProwSuitesMutation) AddedFields() []string {
	var fields []string
	if m.addtime != nil {
		fields = append(fields, prowsuites.FieldTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProwSuitesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case prowsuites.FieldTime:
		return m.AddedTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProwSuitesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case prowsuites.FieldTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTime(v)
		return nil
	}
	return fmt.Errorf("unknown ProwSuites numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProwSuitesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProwSuitesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProwSuitesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProwSuites nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProwSuitesMutation) ResetField(name string) error {
	switch name {
	case prowsuites.FieldJobID:
		m.ResetJobID()
		return nil
	case prowsuites.FieldName:
		m.ResetName()
		return nil
	case prowsuites.FieldStatus:
		m.ResetStatus()
		return nil
	case prowsuites.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown ProwSuites field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProwSuitesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.prow_suites != nil {
		edges = append(edges, prowsuites.EdgeProwSuites)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProwSuitesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prowsuites.EdgeProwSuites:
		if id := m.prow_suites; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProwSuitesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProwSuitesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProwSuitesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprow_suites {
		edges = append(edges, prowsuites.EdgeProwSuites)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProwSuitesMutation) EdgeCleared(name string) bool {
	switch name {
	case prowsuites.EdgeProwSuites:
		return m.clearedprow_suites
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProwSuitesMutation) ClearEdge(name string) error {
	switch name {
	case prowsuites.EdgeProwSuites:
		m.ClearProwSuites()
		return nil
	}
	return fmt.Errorf("unknown ProwSuites unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProwSuitesMutation) ResetEdge(name string) error {
	switch name {
	case prowsuites.EdgeProwSuites:
		m.ResetProwSuites()
		return nil
	}
	return fmt.Errorf("unknown ProwSuites edge %s", name)
}

// PullRequestsMutation represents an operation that mutates the PullRequests nodes in the graph.
type PullRequestsMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	pr_id                   *uuid.UUID
	repository_name         *string
	repository_organization *string
	number                  *int
	addnumber               *int
	created_at              *time.Time
	closed_at               *time.Time
	merged_at               *time.Time
	state                   *string
	author                  *string
	title                   *string
	clearedFields           map[string]struct{}
	prs                     *string
	clearedprs              bool
	done                    bool
	oldValue                func(context.Context) (*PullRequests, error)
	predicates              []predicate.PullRequests
}

var _ ent.Mutation = (*PullRequestsMutation)(nil)

// pullrequestsOption allows management of the mutation configuration using functional options.
type pullrequestsOption func(*PullRequestsMutation)

// newPullRequestsMutation creates new mutation for the PullRequests entity.
func newPullRequestsMutation(c config, op Op, opts ...pullrequestsOption) *PullRequestsMutation {
	m := &PullRequestsMutation{
		config:        c,
		op:            op,
		typ:           TypePullRequests,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPullRequestsID sets the ID field of the mutation.
func withPullRequestsID(id int) pullrequestsOption {
	return func(m *PullRequestsMutation) {
		var (
			err   error
			once  sync.Once
			value *PullRequests
		)
		m.oldValue = func(ctx context.Context) (*PullRequests, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PullRequests.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPullRequests sets the old PullRequests of the mutation.
func withPullRequests(node *PullRequests) pullrequestsOption {
	return func(m *PullRequestsMutation) {
		m.oldValue = func(context.Context) (*PullRequests, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PullRequestsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PullRequestsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PullRequestsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PullRequestsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PullRequests.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPrID sets the "pr_id" field.
func (m *PullRequestsMutation) SetPrID(u uuid.UUID) {
	m.pr_id = &u
}

// PrID returns the value of the "pr_id" field in the mutation.
func (m *PullRequestsMutation) PrID() (r uuid.UUID, exists bool) {
	v := m.pr_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPrID returns the old "pr_id" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldPrID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrID: %w", err)
	}
	return oldValue.PrID, nil
}

// ResetPrID resets all changes to the "pr_id" field.
func (m *PullRequestsMutation) ResetPrID() {
	m.pr_id = nil
}

// SetRepositoryName sets the "repository_name" field.
func (m *PullRequestsMutation) SetRepositoryName(s string) {
	m.repository_name = &s
}

// RepositoryName returns the value of the "repository_name" field in the mutation.
func (m *PullRequestsMutation) RepositoryName() (r string, exists bool) {
	v := m.repository_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRepositoryName returns the old "repository_name" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldRepositoryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepositoryName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepositoryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepositoryName: %w", err)
	}
	return oldValue.RepositoryName, nil
}

// ResetRepositoryName resets all changes to the "repository_name" field.
func (m *PullRequestsMutation) ResetRepositoryName() {
	m.repository_name = nil
}

// SetRepositoryOrganization sets the "repository_organization" field.
func (m *PullRequestsMutation) SetRepositoryOrganization(s string) {
	m.repository_organization = &s
}

// RepositoryOrganization returns the value of the "repository_organization" field in the mutation.
func (m *PullRequestsMutation) RepositoryOrganization() (r string, exists bool) {
	v := m.repository_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldRepositoryOrganization returns the old "repository_organization" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldRepositoryOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepositoryOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepositoryOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepositoryOrganization: %w", err)
	}
	return oldValue.RepositoryOrganization, nil
}

// ResetRepositoryOrganization resets all changes to the "repository_organization" field.
func (m *PullRequestsMutation) ResetRepositoryOrganization() {
	m.repository_organization = nil
}

// SetNumber sets the "number" field.
func (m *PullRequestsMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *PullRequestsMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *PullRequestsMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *PullRequestsMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *PullRequestsMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PullRequestsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PullRequestsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PullRequestsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetClosedAt sets the "closed_at" field.
func (m *PullRequestsMutation) SetClosedAt(t time.Time) {
	m.closed_at = &t
}

// ClosedAt returns the value of the "closed_at" field in the mutation.
func (m *PullRequestsMutation) ClosedAt() (r time.Time, exists bool) {
	v := m.closed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClosedAt returns the old "closed_at" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldClosedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClosedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClosedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosedAt: %w", err)
	}
	return oldValue.ClosedAt, nil
}

// ResetClosedAt resets all changes to the "closed_at" field.
func (m *PullRequestsMutation) ResetClosedAt() {
	m.closed_at = nil
}

// SetMergedAt sets the "merged_at" field.
func (m *PullRequestsMutation) SetMergedAt(t time.Time) {
	m.merged_at = &t
}

// MergedAt returns the value of the "merged_at" field in the mutation.
func (m *PullRequestsMutation) MergedAt() (r time.Time, exists bool) {
	v := m.merged_at
	if v == nil {
		return
	}
	return *v, true
}

// OldMergedAt returns the old "merged_at" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldMergedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMergedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMergedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMergedAt: %w", err)
	}
	return oldValue.MergedAt, nil
}

// ResetMergedAt resets all changes to the "merged_at" field.
func (m *PullRequestsMutation) ResetMergedAt() {
	m.merged_at = nil
}

// SetState sets the "state" field.
func (m *PullRequestsMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *PullRequestsMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *PullRequestsMutation) ResetState() {
	m.state = nil
}

// SetAuthor sets the "author" field.
func (m *PullRequestsMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *PullRequestsMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *PullRequestsMutation) ResetAuthor() {
	m.author = nil
}

// SetTitle sets the "title" field.
func (m *PullRequestsMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PullRequestsMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PullRequestsMutation) ResetTitle() {
	m.title = nil
}

// SetPrsID sets the "prs" edge to the Repository entity by id.
func (m *PullRequestsMutation) SetPrsID(id string) {
	m.prs = &id
}

// ClearPrs clears the "prs" edge to the Repository entity.
func (m *PullRequestsMutation) ClearPrs() {
	m.clearedprs = true
}

// PrsCleared reports if the "prs" edge to the Repository entity was cleared.
func (m *PullRequestsMutation) PrsCleared() bool {
	return m.clearedprs
}

// PrsID returns the "prs" edge ID in the mutation.
func (m *PullRequestsMutation) PrsID() (id string, exists bool) {
	if m.prs != nil {
		return *m.prs, true
	}
	return
}

// PrsIDs returns the "prs" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrsID instead. It exists only for internal usage by the builders.
func (m *PullRequestsMutation) PrsIDs() (ids []string) {
	if id := m.prs; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrs resets all changes to the "prs" edge.
func (m *PullRequestsMutation) ResetPrs() {
	m.prs = nil
	m.clearedprs = false
}

// Where appends a list predicates to the PullRequestsMutation builder.
func (m *PullRequestsMutation) Where(ps ...predicate.PullRequests) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PullRequestsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PullRequestsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PullRequests, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PullRequestsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PullRequestsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PullRequests).
func (m *PullRequestsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PullRequestsMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.pr_id != nil {
		fields = append(fields, pullrequests.FieldPrID)
	}
	if m.repository_name != nil {
		fields = append(fields, pullrequests.FieldRepositoryName)
	}
	if m.repository_organization != nil {
		fields = append(fields, pullrequests.FieldRepositoryOrganization)
	}
	if m.number != nil {
		fields = append(fields, pullrequests.FieldNumber)
	}
	if m.created_at != nil {
		fields = append(fields, pullrequests.FieldCreatedAt)
	}
	if m.closed_at != nil {
		fields = append(fields, pullrequests.FieldClosedAt)
	}
	if m.merged_at != nil {
		fields = append(fields, pullrequests.FieldMergedAt)
	}
	if m.state != nil {
		fields = append(fields, pullrequests.FieldState)
	}
	if m.author != nil {
		fields = append(fields, pullrequests.FieldAuthor)
	}
	if m.title != nil {
		fields = append(fields, pullrequests.FieldTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PullRequestsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pullrequests.FieldPrID:
		return m.PrID()
	case pullrequests.FieldRepositoryName:
		return m.RepositoryName()
	case pullrequests.FieldRepositoryOrganization:
		return m.RepositoryOrganization()
	case pullrequests.FieldNumber:
		return m.Number()
	case pullrequests.FieldCreatedAt:
		return m.CreatedAt()
	case pullrequests.FieldClosedAt:
		return m.ClosedAt()
	case pullrequests.FieldMergedAt:
		return m.MergedAt()
	case pullrequests.FieldState:
		return m.State()
	case pullrequests.FieldAuthor:
		return m.Author()
	case pullrequests.FieldTitle:
		return m.Title()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PullRequestsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pullrequests.FieldPrID:
		return m.OldPrID(ctx)
	case pullrequests.FieldRepositoryName:
		return m.OldRepositoryName(ctx)
	case pullrequests.FieldRepositoryOrganization:
		return m.OldRepositoryOrganization(ctx)
	case pullrequests.FieldNumber:
		return m.OldNumber(ctx)
	case pullrequests.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pullrequests.FieldClosedAt:
		return m.OldClosedAt(ctx)
	case pullrequests.FieldMergedAt:
		return m.OldMergedAt(ctx)
	case pullrequests.FieldState:
		return m.OldState(ctx)
	case pullrequests.FieldAuthor:
		return m.OldAuthor(ctx)
	case pullrequests.FieldTitle:
		return m.OldTitle(ctx)
	}
	return nil, fmt.Errorf("unknown PullRequests field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PullRequestsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pullrequests.FieldPrID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrID(v)
		return nil
	case pullrequests.FieldRepositoryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepositoryName(v)
		return nil
	case pullrequests.FieldRepositoryOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepositoryOrganization(v)
		return nil
	case pullrequests.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case pullrequests.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pullrequests.FieldClosedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosedAt(v)
		return nil
	case pullrequests.FieldMergedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMergedAt(v)
		return nil
	case pullrequests.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case pullrequests.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case pullrequests.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	}
	return fmt.Errorf("unknown PullRequests field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PullRequestsMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, pullrequests.FieldNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PullRequestsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pullrequests.FieldNumber:
		return m.AddedNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PullRequestsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pullrequests.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	}
	return fmt.Errorf("unknown PullRequests numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PullRequestsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PullRequestsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PullRequestsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PullRequests nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PullRequestsMutation) ResetField(name string) error {
	switch name {
	case pullrequests.FieldPrID:
		m.ResetPrID()
		return nil
	case pullrequests.FieldRepositoryName:
		m.ResetRepositoryName()
		return nil
	case pullrequests.FieldRepositoryOrganization:
		m.ResetRepositoryOrganization()
		return nil
	case pullrequests.FieldNumber:
		m.ResetNumber()
		return nil
	case pullrequests.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pullrequests.FieldClosedAt:
		m.ResetClosedAt()
		return nil
	case pullrequests.FieldMergedAt:
		m.ResetMergedAt()
		return nil
	case pullrequests.FieldState:
		m.ResetState()
		return nil
	case pullrequests.FieldAuthor:
		m.ResetAuthor()
		return nil
	case pullrequests.FieldTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown PullRequests field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PullRequestsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.prs != nil {
		edges = append(edges, pullrequests.EdgePrs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PullRequestsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pullrequests.EdgePrs:
		if id := m.prs; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PullRequestsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PullRequestsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PullRequestsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprs {
		edges = append(edges, pullrequests.EdgePrs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PullRequestsMutation) EdgeCleared(name string) bool {
	switch name {
	case pullrequests.EdgePrs:
		return m.clearedprs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PullRequestsMutation) ClearEdge(name string) error {
	switch name {
	case pullrequests.EdgePrs:
		m.ClearPrs()
		return nil
	}
	return fmt.Errorf("unknown PullRequests unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PullRequestsMutation) ResetEdge(name string) error {
	switch name {
	case pullrequests.EdgePrs:
		m.ResetPrs()
		return nil
	}
	return fmt.Errorf("unknown PullRequests edge %s", name)
}

// RepositoryMutation represents an operation that mutates the Repository nodes in the graph.
type RepositoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	repository_name     *string
	git_organization    *string
	description         *string
	git_url             *string
	clearedFields       map[string]struct{}
	repositories        *uuid.UUID
	clearedrepositories bool
	workflows           map[int]struct{}
	removedworkflows    map[int]struct{}
	clearedworkflows    bool
	codecov             map[uuid.UUID]struct{}
	removedcodecov      map[uuid.UUID]struct{}
	clearedcodecov      bool
	prow_suites         map[int]struct{}
	removedprow_suites  map[int]struct{}
	clearedprow_suites  bool
	prow_jobs           map[int]struct{}
	removedprow_jobs    map[int]struct{}
	clearedprow_jobs    bool
	prs                 map[int]struct{}
	removedprs          map[int]struct{}
	clearedprs          bool
	done                bool
	oldValue            func(context.Context) (*Repository, error)
	predicates          []predicate.Repository
}

var _ ent.Mutation = (*RepositoryMutation)(nil)

// repositoryOption allows management of the mutation configuration using functional options.
type repositoryOption func(*RepositoryMutation)

// newRepositoryMutation creates new mutation for the Repository entity.
func newRepositoryMutation(c config, op Op, opts ...repositoryOption) *RepositoryMutation {
	m := &RepositoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRepository,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepositoryID sets the ID field of the mutation.
func withRepositoryID(id string) repositoryOption {
	return func(m *RepositoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Repository
		)
		m.oldValue = func(ctx context.Context) (*Repository, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repository.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepository sets the old Repository of the mutation.
func withRepository(node *Repository) repositoryOption {
	return func(m *RepositoryMutation) {
		m.oldValue = func(context.Context) (*Repository, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepositoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepositoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Repository entities.
func (m *RepositoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RepositoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RepositoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Repository.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRepositoryName sets the "repository_name" field.
func (m *RepositoryMutation) SetRepositoryName(s string) {
	m.repository_name = &s
}

// RepositoryName returns the value of the "repository_name" field in the mutation.
func (m *RepositoryMutation) RepositoryName() (r string, exists bool) {
	v := m.repository_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRepositoryName returns the old "repository_name" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldRepositoryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepositoryName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepositoryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepositoryName: %w", err)
	}
	return oldValue.RepositoryName, nil
}

// ResetRepositoryName resets all changes to the "repository_name" field.
func (m *RepositoryMutation) ResetRepositoryName() {
	m.repository_name = nil
}

// SetGitOrganization sets the "git_organization" field.
func (m *RepositoryMutation) SetGitOrganization(s string) {
	m.git_organization = &s
}

// GitOrganization returns the value of the "git_organization" field in the mutation.
func (m *RepositoryMutation) GitOrganization() (r string, exists bool) {
	v := m.git_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldGitOrganization returns the old "git_organization" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldGitOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitOrganization: %w", err)
	}
	return oldValue.GitOrganization, nil
}

// ResetGitOrganization resets all changes to the "git_organization" field.
func (m *RepositoryMutation) ResetGitOrganization() {
	m.git_organization = nil
}

// SetDescription sets the "description" field.
func (m *RepositoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RepositoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RepositoryMutation) ResetDescription() {
	m.description = nil
}

// SetGitURL sets the "git_url" field.
func (m *RepositoryMutation) SetGitURL(s string) {
	m.git_url = &s
}

// GitURL returns the value of the "git_url" field in the mutation.
func (m *RepositoryMutation) GitURL() (r string, exists bool) {
	v := m.git_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGitURL returns the old "git_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldGitURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitURL: %w", err)
	}
	return oldValue.GitURL, nil
}

// ResetGitURL resets all changes to the "git_url" field.
func (m *RepositoryMutation) ResetGitURL() {
	m.git_url = nil
}

// SetRepositoriesID sets the "repositories" edge to the Teams entity by id.
func (m *RepositoryMutation) SetRepositoriesID(id uuid.UUID) {
	m.repositories = &id
}

// ClearRepositories clears the "repositories" edge to the Teams entity.
func (m *RepositoryMutation) ClearRepositories() {
	m.clearedrepositories = true
}

// RepositoriesCleared reports if the "repositories" edge to the Teams entity was cleared.
func (m *RepositoryMutation) RepositoriesCleared() bool {
	return m.clearedrepositories
}

// RepositoriesID returns the "repositories" edge ID in the mutation.
func (m *RepositoryMutation) RepositoriesID() (id uuid.UUID, exists bool) {
	if m.repositories != nil {
		return *m.repositories, true
	}
	return
}

// RepositoriesIDs returns the "repositories" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepositoriesID instead. It exists only for internal usage by the builders.
func (m *RepositoryMutation) RepositoriesIDs() (ids []uuid.UUID) {
	if id := m.repositories; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepositories resets all changes to the "repositories" edge.
func (m *RepositoryMutation) ResetRepositories() {
	m.repositories = nil
	m.clearedrepositories = false
}

// AddWorkflowIDs adds the "workflows" edge to the Workflows entity by ids.
func (m *RepositoryMutation) AddWorkflowIDs(ids ...int) {
	if m.workflows == nil {
		m.workflows = make(map[int]struct{})
	}
	for i := range ids {
		m.workflows[ids[i]] = struct{}{}
	}
}

// ClearWorkflows clears the "workflows" edge to the Workflows entity.
func (m *RepositoryMutation) ClearWorkflows() {
	m.clearedworkflows = true
}

// WorkflowsCleared reports if the "workflows" edge to the Workflows entity was cleared.
func (m *RepositoryMutation) WorkflowsCleared() bool {
	return m.clearedworkflows
}

// RemoveWorkflowIDs removes the "workflows" edge to the Workflows entity by IDs.
func (m *RepositoryMutation) RemoveWorkflowIDs(ids ...int) {
	if m.removedworkflows == nil {
		m.removedworkflows = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.workflows, ids[i])
		m.removedworkflows[ids[i]] = struct{}{}
	}
}

// RemovedWorkflows returns the removed IDs of the "workflows" edge to the Workflows entity.
func (m *RepositoryMutation) RemovedWorkflowsIDs() (ids []int) {
	for id := range m.removedworkflows {
		ids = append(ids, id)
	}
	return
}

// WorkflowsIDs returns the "workflows" edge IDs in the mutation.
func (m *RepositoryMutation) WorkflowsIDs() (ids []int) {
	for id := range m.workflows {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflows resets all changes to the "workflows" edge.
func (m *RepositoryMutation) ResetWorkflows() {
	m.workflows = nil
	m.clearedworkflows = false
	m.removedworkflows = nil
}

// AddCodecovIDs adds the "codecov" edge to the CodeCov entity by ids.
func (m *RepositoryMutation) AddCodecovIDs(ids ...uuid.UUID) {
	if m.codecov == nil {
		m.codecov = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.codecov[ids[i]] = struct{}{}
	}
}

// ClearCodecov clears the "codecov" edge to the CodeCov entity.
func (m *RepositoryMutation) ClearCodecov() {
	m.clearedcodecov = true
}

// CodecovCleared reports if the "codecov" edge to the CodeCov entity was cleared.
func (m *RepositoryMutation) CodecovCleared() bool {
	return m.clearedcodecov
}

// RemoveCodecovIDs removes the "codecov" edge to the CodeCov entity by IDs.
func (m *RepositoryMutation) RemoveCodecovIDs(ids ...uuid.UUID) {
	if m.removedcodecov == nil {
		m.removedcodecov = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.codecov, ids[i])
		m.removedcodecov[ids[i]] = struct{}{}
	}
}

// RemovedCodecov returns the removed IDs of the "codecov" edge to the CodeCov entity.
func (m *RepositoryMutation) RemovedCodecovIDs() (ids []uuid.UUID) {
	for id := range m.removedcodecov {
		ids = append(ids, id)
	}
	return
}

// CodecovIDs returns the "codecov" edge IDs in the mutation.
func (m *RepositoryMutation) CodecovIDs() (ids []uuid.UUID) {
	for id := range m.codecov {
		ids = append(ids, id)
	}
	return
}

// ResetCodecov resets all changes to the "codecov" edge.
func (m *RepositoryMutation) ResetCodecov() {
	m.codecov = nil
	m.clearedcodecov = false
	m.removedcodecov = nil
}

// AddProwSuiteIDs adds the "prow_suites" edge to the ProwSuites entity by ids.
func (m *RepositoryMutation) AddProwSuiteIDs(ids ...int) {
	if m.prow_suites == nil {
		m.prow_suites = make(map[int]struct{})
	}
	for i := range ids {
		m.prow_suites[ids[i]] = struct{}{}
	}
}

// ClearProwSuites clears the "prow_suites" edge to the ProwSuites entity.
func (m *RepositoryMutation) ClearProwSuites() {
	m.clearedprow_suites = true
}

// ProwSuitesCleared reports if the "prow_suites" edge to the ProwSuites entity was cleared.
func (m *RepositoryMutation) ProwSuitesCleared() bool {
	return m.clearedprow_suites
}

// RemoveProwSuiteIDs removes the "prow_suites" edge to the ProwSuites entity by IDs.
func (m *RepositoryMutation) RemoveProwSuiteIDs(ids ...int) {
	if m.removedprow_suites == nil {
		m.removedprow_suites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.prow_suites, ids[i])
		m.removedprow_suites[ids[i]] = struct{}{}
	}
}

// RemovedProwSuites returns the removed IDs of the "prow_suites" edge to the ProwSuites entity.
func (m *RepositoryMutation) RemovedProwSuitesIDs() (ids []int) {
	for id := range m.removedprow_suites {
		ids = append(ids, id)
	}
	return
}

// ProwSuitesIDs returns the "prow_suites" edge IDs in the mutation.
func (m *RepositoryMutation) ProwSuitesIDs() (ids []int) {
	for id := range m.prow_suites {
		ids = append(ids, id)
	}
	return
}

// ResetProwSuites resets all changes to the "prow_suites" edge.
func (m *RepositoryMutation) ResetProwSuites() {
	m.prow_suites = nil
	m.clearedprow_suites = false
	m.removedprow_suites = nil
}

// AddProwJobIDs adds the "prow_jobs" edge to the ProwJobs entity by ids.
func (m *RepositoryMutation) AddProwJobIDs(ids ...int) {
	if m.prow_jobs == nil {
		m.prow_jobs = make(map[int]struct{})
	}
	for i := range ids {
		m.prow_jobs[ids[i]] = struct{}{}
	}
}

// ClearProwJobs clears the "prow_jobs" edge to the ProwJobs entity.
func (m *RepositoryMutation) ClearProwJobs() {
	m.clearedprow_jobs = true
}

// ProwJobsCleared reports if the "prow_jobs" edge to the ProwJobs entity was cleared.
func (m *RepositoryMutation) ProwJobsCleared() bool {
	return m.clearedprow_jobs
}

// RemoveProwJobIDs removes the "prow_jobs" edge to the ProwJobs entity by IDs.
func (m *RepositoryMutation) RemoveProwJobIDs(ids ...int) {
	if m.removedprow_jobs == nil {
		m.removedprow_jobs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.prow_jobs, ids[i])
		m.removedprow_jobs[ids[i]] = struct{}{}
	}
}

// RemovedProwJobs returns the removed IDs of the "prow_jobs" edge to the ProwJobs entity.
func (m *RepositoryMutation) RemovedProwJobsIDs() (ids []int) {
	for id := range m.removedprow_jobs {
		ids = append(ids, id)
	}
	return
}

// ProwJobsIDs returns the "prow_jobs" edge IDs in the mutation.
func (m *RepositoryMutation) ProwJobsIDs() (ids []int) {
	for id := range m.prow_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetProwJobs resets all changes to the "prow_jobs" edge.
func (m *RepositoryMutation) ResetProwJobs() {
	m.prow_jobs = nil
	m.clearedprow_jobs = false
	m.removedprow_jobs = nil
}

// AddPrIDs adds the "prs" edge to the PullRequests entity by ids.
func (m *RepositoryMutation) AddPrIDs(ids ...int) {
	if m.prs == nil {
		m.prs = make(map[int]struct{})
	}
	for i := range ids {
		m.prs[ids[i]] = struct{}{}
	}
}

// ClearPrs clears the "prs" edge to the PullRequests entity.
func (m *RepositoryMutation) ClearPrs() {
	m.clearedprs = true
}

// PrsCleared reports if the "prs" edge to the PullRequests entity was cleared.
func (m *RepositoryMutation) PrsCleared() bool {
	return m.clearedprs
}

// RemovePrIDs removes the "prs" edge to the PullRequests entity by IDs.
func (m *RepositoryMutation) RemovePrIDs(ids ...int) {
	if m.removedprs == nil {
		m.removedprs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.prs, ids[i])
		m.removedprs[ids[i]] = struct{}{}
	}
}

// RemovedPrs returns the removed IDs of the "prs" edge to the PullRequests entity.
func (m *RepositoryMutation) RemovedPrsIDs() (ids []int) {
	for id := range m.removedprs {
		ids = append(ids, id)
	}
	return
}

// PrsIDs returns the "prs" edge IDs in the mutation.
func (m *RepositoryMutation) PrsIDs() (ids []int) {
	for id := range m.prs {
		ids = append(ids, id)
	}
	return
}

// ResetPrs resets all changes to the "prs" edge.
func (m *RepositoryMutation) ResetPrs() {
	m.prs = nil
	m.clearedprs = false
	m.removedprs = nil
}

// Where appends a list predicates to the RepositoryMutation builder.
func (m *RepositoryMutation) Where(ps ...predicate.Repository) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RepositoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RepositoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Repository, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RepositoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RepositoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Repository).
func (m *RepositoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RepositoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.repository_name != nil {
		fields = append(fields, repository.FieldRepositoryName)
	}
	if m.git_organization != nil {
		fields = append(fields, repository.FieldGitOrganization)
	}
	if m.description != nil {
		fields = append(fields, repository.FieldDescription)
	}
	if m.git_url != nil {
		fields = append(fields, repository.FieldGitURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RepositoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repository.FieldRepositoryName:
		return m.RepositoryName()
	case repository.FieldGitOrganization:
		return m.GitOrganization()
	case repository.FieldDescription:
		return m.Description()
	case repository.FieldGitURL:
		return m.GitURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RepositoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repository.FieldRepositoryName:
		return m.OldRepositoryName(ctx)
	case repository.FieldGitOrganization:
		return m.OldGitOrganization(ctx)
	case repository.FieldDescription:
		return m.OldDescription(ctx)
	case repository.FieldGitURL:
		return m.OldGitURL(ctx)
	}
	return nil, fmt.Errorf("unknown Repository field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repository.FieldRepositoryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepositoryName(v)
		return nil
	case repository.FieldGitOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitOrganization(v)
		return nil
	case repository.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case repository.FieldGitURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitURL(v)
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RepositoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RepositoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Repository numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RepositoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RepositoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepositoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Repository nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RepositoryMutation) ResetField(name string) error {
	switch name {
	case repository.FieldRepositoryName:
		m.ResetRepositoryName()
		return nil
	case repository.FieldGitOrganization:
		m.ResetGitOrganization()
		return nil
	case repository.FieldDescription:
		m.ResetDescription()
		return nil
	case repository.FieldGitURL:
		m.ResetGitURL()
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RepositoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.repositories != nil {
		edges = append(edges, repository.EdgeRepositories)
	}
	if m.workflows != nil {
		edges = append(edges, repository.EdgeWorkflows)
	}
	if m.codecov != nil {
		edges = append(edges, repository.EdgeCodecov)
	}
	if m.prow_suites != nil {
		edges = append(edges, repository.EdgeProwSuites)
	}
	if m.prow_jobs != nil {
		edges = append(edges, repository.EdgeProwJobs)
	}
	if m.prs != nil {
		edges = append(edges, repository.EdgePrs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RepositoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgeRepositories:
		if id := m.repositories; id != nil {
			return []ent.Value{*id}
		}
	case repository.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.workflows))
		for id := range m.workflows {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeCodecov:
		ids := make([]ent.Value, 0, len(m.codecov))
		for id := range m.codecov {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeProwSuites:
		ids := make([]ent.Value, 0, len(m.prow_suites))
		for id := range m.prow_suites {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeProwJobs:
		ids := make([]ent.Value, 0, len(m.prow_jobs))
		for id := range m.prow_jobs {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgePrs:
		ids := make([]ent.Value, 0, len(m.prs))
		for id := range m.prs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RepositoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedworkflows != nil {
		edges = append(edges, repository.EdgeWorkflows)
	}
	if m.removedcodecov != nil {
		edges = append(edges, repository.EdgeCodecov)
	}
	if m.removedprow_suites != nil {
		edges = append(edges, repository.EdgeProwSuites)
	}
	if m.removedprow_jobs != nil {
		edges = append(edges, repository.EdgeProwJobs)
	}
	if m.removedprs != nil {
		edges = append(edges, repository.EdgePrs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RepositoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.removedworkflows))
		for id := range m.removedworkflows {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeCodecov:
		ids := make([]ent.Value, 0, len(m.removedcodecov))
		for id := range m.removedcodecov {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeProwSuites:
		ids := make([]ent.Value, 0, len(m.removedprow_suites))
		for id := range m.removedprow_suites {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeProwJobs:
		ids := make([]ent.Value, 0, len(m.removedprow_jobs))
		for id := range m.removedprow_jobs {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgePrs:
		ids := make([]ent.Value, 0, len(m.removedprs))
		for id := range m.removedprs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RepositoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedrepositories {
		edges = append(edges, repository.EdgeRepositories)
	}
	if m.clearedworkflows {
		edges = append(edges, repository.EdgeWorkflows)
	}
	if m.clearedcodecov {
		edges = append(edges, repository.EdgeCodecov)
	}
	if m.clearedprow_suites {
		edges = append(edges, repository.EdgeProwSuites)
	}
	if m.clearedprow_jobs {
		edges = append(edges, repository.EdgeProwJobs)
	}
	if m.clearedprs {
		edges = append(edges, repository.EdgePrs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RepositoryMutation) EdgeCleared(name string) bool {
	switch name {
	case repository.EdgeRepositories:
		return m.clearedrepositories
	case repository.EdgeWorkflows:
		return m.clearedworkflows
	case repository.EdgeCodecov:
		return m.clearedcodecov
	case repository.EdgeProwSuites:
		return m.clearedprow_suites
	case repository.EdgeProwJobs:
		return m.clearedprow_jobs
	case repository.EdgePrs:
		return m.clearedprs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RepositoryMutation) ClearEdge(name string) error {
	switch name {
	case repository.EdgeRepositories:
		m.ClearRepositories()
		return nil
	}
	return fmt.Errorf("unknown Repository unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RepositoryMutation) ResetEdge(name string) error {
	switch name {
	case repository.EdgeRepositories:
		m.ResetRepositories()
		return nil
	case repository.EdgeWorkflows:
		m.ResetWorkflows()
		return nil
	case repository.EdgeCodecov:
		m.ResetCodecov()
		return nil
	case repository.EdgeProwSuites:
		m.ResetProwSuites()
		return nil
	case repository.EdgeProwJobs:
		m.ResetProwJobs()
		return nil
	case repository.EdgePrs:
		m.ResetPrs()
		return nil
	}
	return fmt.Errorf("unknown Repository edge %s", name)
}

// TeamsMutation represents an operation that mutates the Teams nodes in the graph.
type TeamsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	team_name           *string
	description         *string
	jira_keys           *string
	clearedFields       map[string]struct{}
	repositories        map[string]struct{}
	removedrepositories map[string]struct{}
	clearedrepositories bool
	bugs                map[uuid.UUID]struct{}
	removedbugs         map[uuid.UUID]struct{}
	clearedbugs         bool
	done                bool
	oldValue            func(context.Context) (*Teams, error)
	predicates          []predicate.Teams
}

var _ ent.Mutation = (*TeamsMutation)(nil)

// teamsOption allows management of the mutation configuration using functional options.
type teamsOption func(*TeamsMutation)

// newTeamsMutation creates new mutation for the Teams entity.
func newTeamsMutation(c config, op Op, opts ...teamsOption) *TeamsMutation {
	m := &TeamsMutation{
		config:        c,
		op:            op,
		typ:           TypeTeams,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamsID sets the ID field of the mutation.
func withTeamsID(id uuid.UUID) teamsOption {
	return func(m *TeamsMutation) {
		var (
			err   error
			once  sync.Once
			value *Teams
		)
		m.oldValue = func(ctx context.Context) (*Teams, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Teams.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeams sets the old Teams of the mutation.
func withTeams(node *Teams) teamsOption {
	return func(m *TeamsMutation) {
		m.oldValue = func(context.Context) (*Teams, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Teams entities.
func (m *TeamsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Teams.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTeamName sets the "team_name" field.
func (m *TeamsMutation) SetTeamName(s string) {
	m.team_name = &s
}

// TeamName returns the value of the "team_name" field in the mutation.
func (m *TeamsMutation) TeamName() (r string, exists bool) {
	v := m.team_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamName returns the old "team_name" field's value of the Teams entity.
// If the Teams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamsMutation) OldTeamName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamName: %w", err)
	}
	return oldValue.TeamName, nil
}

// ResetTeamName resets all changes to the "team_name" field.
func (m *TeamsMutation) ResetTeamName() {
	m.team_name = nil
}

// SetDescription sets the "description" field.
func (m *TeamsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TeamsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Teams entity.
// If the Teams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TeamsMutation) ResetDescription() {
	m.description = nil
}

// SetJiraKeys sets the "jira_keys" field.
func (m *TeamsMutation) SetJiraKeys(s string) {
	m.jira_keys = &s
}

// JiraKeys returns the value of the "jira_keys" field in the mutation.
func (m *TeamsMutation) JiraKeys() (r string, exists bool) {
	v := m.jira_keys
	if v == nil {
		return
	}
	return *v, true
}

// OldJiraKeys returns the old "jira_keys" field's value of the Teams entity.
// If the Teams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamsMutation) OldJiraKeys(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJiraKeys is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJiraKeys requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJiraKeys: %w", err)
	}
	return oldValue.JiraKeys, nil
}

// ResetJiraKeys resets all changes to the "jira_keys" field.
func (m *TeamsMutation) ResetJiraKeys() {
	m.jira_keys = nil
}

// AddRepositoryIDs adds the "repositories" edge to the Repository entity by ids.
func (m *TeamsMutation) AddRepositoryIDs(ids ...string) {
	if m.repositories == nil {
		m.repositories = make(map[string]struct{})
	}
	for i := range ids {
		m.repositories[ids[i]] = struct{}{}
	}
}

// ClearRepositories clears the "repositories" edge to the Repository entity.
func (m *TeamsMutation) ClearRepositories() {
	m.clearedrepositories = true
}

// RepositoriesCleared reports if the "repositories" edge to the Repository entity was cleared.
func (m *TeamsMutation) RepositoriesCleared() bool {
	return m.clearedrepositories
}

// RemoveRepositoryIDs removes the "repositories" edge to the Repository entity by IDs.
func (m *TeamsMutation) RemoveRepositoryIDs(ids ...string) {
	if m.removedrepositories == nil {
		m.removedrepositories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.repositories, ids[i])
		m.removedrepositories[ids[i]] = struct{}{}
	}
}

// RemovedRepositories returns the removed IDs of the "repositories" edge to the Repository entity.
func (m *TeamsMutation) RemovedRepositoriesIDs() (ids []string) {
	for id := range m.removedrepositories {
		ids = append(ids, id)
	}
	return
}

// RepositoriesIDs returns the "repositories" edge IDs in the mutation.
func (m *TeamsMutation) RepositoriesIDs() (ids []string) {
	for id := range m.repositories {
		ids = append(ids, id)
	}
	return
}

// ResetRepositories resets all changes to the "repositories" edge.
func (m *TeamsMutation) ResetRepositories() {
	m.repositories = nil
	m.clearedrepositories = false
	m.removedrepositories = nil
}

// AddBugIDs adds the "bugs" edge to the Bugs entity by ids.
func (m *TeamsMutation) AddBugIDs(ids ...uuid.UUID) {
	if m.bugs == nil {
		m.bugs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bugs[ids[i]] = struct{}{}
	}
}

// ClearBugs clears the "bugs" edge to the Bugs entity.
func (m *TeamsMutation) ClearBugs() {
	m.clearedbugs = true
}

// BugsCleared reports if the "bugs" edge to the Bugs entity was cleared.
func (m *TeamsMutation) BugsCleared() bool {
	return m.clearedbugs
}

// RemoveBugIDs removes the "bugs" edge to the Bugs entity by IDs.
func (m *TeamsMutation) RemoveBugIDs(ids ...uuid.UUID) {
	if m.removedbugs == nil {
		m.removedbugs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bugs, ids[i])
		m.removedbugs[ids[i]] = struct{}{}
	}
}

// RemovedBugs returns the removed IDs of the "bugs" edge to the Bugs entity.
func (m *TeamsMutation) RemovedBugsIDs() (ids []uuid.UUID) {
	for id := range m.removedbugs {
		ids = append(ids, id)
	}
	return
}

// BugsIDs returns the "bugs" edge IDs in the mutation.
func (m *TeamsMutation) BugsIDs() (ids []uuid.UUID) {
	for id := range m.bugs {
		ids = append(ids, id)
	}
	return
}

// ResetBugs resets all changes to the "bugs" edge.
func (m *TeamsMutation) ResetBugs() {
	m.bugs = nil
	m.clearedbugs = false
	m.removedbugs = nil
}

// Where appends a list predicates to the TeamsMutation builder.
func (m *TeamsMutation) Where(ps ...predicate.Teams) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Teams, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Teams).
func (m *TeamsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.team_name != nil {
		fields = append(fields, teams.FieldTeamName)
	}
	if m.description != nil {
		fields = append(fields, teams.FieldDescription)
	}
	if m.jira_keys != nil {
		fields = append(fields, teams.FieldJiraKeys)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teams.FieldTeamName:
		return m.TeamName()
	case teams.FieldDescription:
		return m.Description()
	case teams.FieldJiraKeys:
		return m.JiraKeys()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teams.FieldTeamName:
		return m.OldTeamName(ctx)
	case teams.FieldDescription:
		return m.OldDescription(ctx)
	case teams.FieldJiraKeys:
		return m.OldJiraKeys(ctx)
	}
	return nil, fmt.Errorf("unknown Teams field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teams.FieldTeamName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamName(v)
		return nil
	case teams.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case teams.FieldJiraKeys:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJiraKeys(v)
		return nil
	}
	return fmt.Errorf("unknown Teams field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Teams numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Teams nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamsMutation) ResetField(name string) error {
	switch name {
	case teams.FieldTeamName:
		m.ResetTeamName()
		return nil
	case teams.FieldDescription:
		m.ResetDescription()
		return nil
	case teams.FieldJiraKeys:
		m.ResetJiraKeys()
		return nil
	}
	return fmt.Errorf("unknown Teams field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.repositories != nil {
		edges = append(edges, teams.EdgeRepositories)
	}
	if m.bugs != nil {
		edges = append(edges, teams.EdgeBugs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teams.EdgeRepositories:
		ids := make([]ent.Value, 0, len(m.repositories))
		for id := range m.repositories {
			ids = append(ids, id)
		}
		return ids
	case teams.EdgeBugs:
		ids := make([]ent.Value, 0, len(m.bugs))
		for id := range m.bugs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrepositories != nil {
		edges = append(edges, teams.EdgeRepositories)
	}
	if m.removedbugs != nil {
		edges = append(edges, teams.EdgeBugs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case teams.EdgeRepositories:
		ids := make([]ent.Value, 0, len(m.removedrepositories))
		for id := range m.removedrepositories {
			ids = append(ids, id)
		}
		return ids
	case teams.EdgeBugs:
		ids := make([]ent.Value, 0, len(m.removedbugs))
		for id := range m.removedbugs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrepositories {
		edges = append(edges, teams.EdgeRepositories)
	}
	if m.clearedbugs {
		edges = append(edges, teams.EdgeBugs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamsMutation) EdgeCleared(name string) bool {
	switch name {
	case teams.EdgeRepositories:
		return m.clearedrepositories
	case teams.EdgeBugs:
		return m.clearedbugs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamsMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Teams unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamsMutation) ResetEdge(name string) error {
	switch name {
	case teams.EdgeRepositories:
		m.ResetRepositories()
		return nil
	case teams.EdgeBugs:
		m.ResetBugs()
		return nil
	}
	return fmt.Errorf("unknown Teams edge %s", name)
}

// WorkflowsMutation represents an operation that mutates the Workflows nodes in the graph.
type WorkflowsMutation struct {
	config
	op               Op
	typ              string
	id               *int
	workflow_id      *uuid.UUID
	workflow_name    *string
	badge_url        *string
	html_url         *string
	job_url          *string
	state            *string
	clearedFields    map[string]struct{}
	workflows        *string
	clearedworkflows bool
	done             bool
	oldValue         func(context.Context) (*Workflows, error)
	predicates       []predicate.Workflows
}

var _ ent.Mutation = (*WorkflowsMutation)(nil)

// workflowsOption allows management of the mutation configuration using functional options.
type workflowsOption func(*WorkflowsMutation)

// newWorkflowsMutation creates new mutation for the Workflows entity.
func newWorkflowsMutation(c config, op Op, opts ...workflowsOption) *WorkflowsMutation {
	m := &WorkflowsMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflows,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowsID sets the ID field of the mutation.
func withWorkflowsID(id int) workflowsOption {
	return func(m *WorkflowsMutation) {
		var (
			err   error
			once  sync.Once
			value *Workflows
		)
		m.oldValue = func(ctx context.Context) (*Workflows, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workflows.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflows sets the old Workflows of the mutation.
func withWorkflows(node *Workflows) workflowsOption {
	return func(m *WorkflowsMutation) {
		m.oldValue = func(context.Context) (*Workflows, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workflows.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkflowID sets the "workflow_id" field.
func (m *WorkflowsMutation) SetWorkflowID(u uuid.UUID) {
	m.workflow_id = &u
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *WorkflowsMutation) WorkflowID() (r uuid.UUID, exists bool) {
	v := m.workflow_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the Workflows entity.
// If the Workflows object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowsMutation) OldWorkflowID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *WorkflowsMutation) ResetWorkflowID() {
	m.workflow_id = nil
}

// SetWorkflowName sets the "workflow_name" field.
func (m *WorkflowsMutation) SetWorkflowName(s string) {
	m.workflow_name = &s
}

// WorkflowName returns the value of the "workflow_name" field in the mutation.
func (m *WorkflowsMutation) WorkflowName() (r string, exists bool) {
	v := m.workflow_name
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowName returns the old "workflow_name" field's value of the Workflows entity.
// If the Workflows object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowsMutation) OldWorkflowName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowName: %w", err)
	}
	return oldValue.WorkflowName, nil
}

// ResetWorkflowName resets all changes to the "workflow_name" field.
func (m *WorkflowsMutation) ResetWorkflowName() {
	m.workflow_name = nil
}

// SetBadgeURL sets the "badge_url" field.
func (m *WorkflowsMutation) SetBadgeURL(s string) {
	m.badge_url = &s
}

// BadgeURL returns the value of the "badge_url" field in the mutation.
func (m *WorkflowsMutation) BadgeURL() (r string, exists bool) {
	v := m.badge_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBadgeURL returns the old "badge_url" field's value of the Workflows entity.
// If the Workflows object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowsMutation) OldBadgeURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBadgeURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBadgeURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBadgeURL: %w", err)
	}
	return oldValue.BadgeURL, nil
}

// ResetBadgeURL resets all changes to the "badge_url" field.
func (m *WorkflowsMutation) ResetBadgeURL() {
	m.badge_url = nil
}

// SetHTMLURL sets the "html_url" field.
func (m *WorkflowsMutation) SetHTMLURL(s string) {
	m.html_url = &s
}

// HTMLURL returns the value of the "html_url" field in the mutation.
func (m *WorkflowsMutation) HTMLURL() (r string, exists bool) {
	v := m.html_url
	if v == nil {
		return
	}
	return *v, true
}

// OldHTMLURL returns the old "html_url" field's value of the Workflows entity.
// If the Workflows object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowsMutation) OldHTMLURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTMLURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTMLURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTMLURL: %w", err)
	}
	return oldValue.HTMLURL, nil
}

// ResetHTMLURL resets all changes to the "html_url" field.
func (m *WorkflowsMutation) ResetHTMLURL() {
	m.html_url = nil
}

// SetJobURL sets the "job_url" field.
func (m *WorkflowsMutation) SetJobURL(s string) {
	m.job_url = &s
}

// JobURL returns the value of the "job_url" field in the mutation.
func (m *WorkflowsMutation) JobURL() (r string, exists bool) {
	v := m.job_url
	if v == nil {
		return
	}
	return *v, true
}

// OldJobURL returns the old "job_url" field's value of the Workflows entity.
// If the Workflows object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowsMutation) OldJobURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobURL: %w", err)
	}
	return oldValue.JobURL, nil
}

// ResetJobURL resets all changes to the "job_url" field.
func (m *WorkflowsMutation) ResetJobURL() {
	m.job_url = nil
}

// SetState sets the "state" field.
func (m *WorkflowsMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *WorkflowsMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Workflows entity.
// If the Workflows object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowsMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *WorkflowsMutation) ResetState() {
	m.state = nil
}

// SetWorkflowsID sets the "workflows" edge to the Repository entity by id.
func (m *WorkflowsMutation) SetWorkflowsID(id string) {
	m.workflows = &id
}

// ClearWorkflows clears the "workflows" edge to the Repository entity.
func (m *WorkflowsMutation) ClearWorkflows() {
	m.clearedworkflows = true
}

// WorkflowsCleared reports if the "workflows" edge to the Repository entity was cleared.
func (m *WorkflowsMutation) WorkflowsCleared() bool {
	return m.clearedworkflows
}

// WorkflowsID returns the "workflows" edge ID in the mutation.
func (m *WorkflowsMutation) WorkflowsID() (id string, exists bool) {
	if m.workflows != nil {
		return *m.workflows, true
	}
	return
}

// WorkflowsIDs returns the "workflows" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowsID instead. It exists only for internal usage by the builders.
func (m *WorkflowsMutation) WorkflowsIDs() (ids []string) {
	if id := m.workflows; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflows resets all changes to the "workflows" edge.
func (m *WorkflowsMutation) ResetWorkflows() {
	m.workflows = nil
	m.clearedworkflows = false
}

// Where appends a list predicates to the WorkflowsMutation builder.
func (m *WorkflowsMutation) Where(ps ...predicate.Workflows) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Workflows, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Workflows).
func (m *WorkflowsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.workflow_id != nil {
		fields = append(fields, workflows.FieldWorkflowID)
	}
	if m.workflow_name != nil {
		fields = append(fields, workflows.FieldWorkflowName)
	}
	if m.badge_url != nil {
		fields = append(fields, workflows.FieldBadgeURL)
	}
	if m.html_url != nil {
		fields = append(fields, workflows.FieldHTMLURL)
	}
	if m.job_url != nil {
		fields = append(fields, workflows.FieldJobURL)
	}
	if m.state != nil {
		fields = append(fields, workflows.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflows.FieldWorkflowID:
		return m.WorkflowID()
	case workflows.FieldWorkflowName:
		return m.WorkflowName()
	case workflows.FieldBadgeURL:
		return m.BadgeURL()
	case workflows.FieldHTMLURL:
		return m.HTMLURL()
	case workflows.FieldJobURL:
		return m.JobURL()
	case workflows.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflows.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case workflows.FieldWorkflowName:
		return m.OldWorkflowName(ctx)
	case workflows.FieldBadgeURL:
		return m.OldBadgeURL(ctx)
	case workflows.FieldHTMLURL:
		return m.OldHTMLURL(ctx)
	case workflows.FieldJobURL:
		return m.OldJobURL(ctx)
	case workflows.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown Workflows field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflows.FieldWorkflowID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case workflows.FieldWorkflowName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowName(v)
		return nil
	case workflows.FieldBadgeURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBadgeURL(v)
		return nil
	case workflows.FieldHTMLURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTMLURL(v)
		return nil
	case workflows.FieldJobURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobURL(v)
		return nil
	case workflows.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown Workflows field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Workflows numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Workflows nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowsMutation) ResetField(name string) error {
	switch name {
	case workflows.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case workflows.FieldWorkflowName:
		m.ResetWorkflowName()
		return nil
	case workflows.FieldBadgeURL:
		m.ResetBadgeURL()
		return nil
	case workflows.FieldHTMLURL:
		m.ResetHTMLURL()
		return nil
	case workflows.FieldJobURL:
		m.ResetJobURL()
		return nil
	case workflows.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown Workflows field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workflows != nil {
		edges = append(edges, workflows.EdgeWorkflows)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflows.EdgeWorkflows:
		if id := m.workflows; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkflows {
		edges = append(edges, workflows.EdgeWorkflows)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowsMutation) EdgeCleared(name string) bool {
	switch name {
	case workflows.EdgeWorkflows:
		return m.clearedworkflows
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowsMutation) ClearEdge(name string) error {
	switch name {
	case workflows.EdgeWorkflows:
		m.ClearWorkflows()
		return nil
	}
	return fmt.Errorf("unknown Workflows unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowsMutation) ResetEdge(name string) error {
	switch name {
	case workflows.EdgeWorkflows:
		m.ResetWorkflows()
		return nil
	}
	return fmt.Errorf("unknown Workflows edge %s", name)
}
