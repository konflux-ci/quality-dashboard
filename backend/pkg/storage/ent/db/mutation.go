// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/bugs"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/codecov"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/failure"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/predicate"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/prowjobs"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/prowsuites"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/pullrequests"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/repository"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/teams"
	"github.com/redhat-appstudio/quality-studio/pkg/storage/ent/db/workflows"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBugs         = "Bugs"
	TypeCodeCov      = "CodeCov"
	TypeFailure      = "Failure"
	TypeProwJobs     = "ProwJobs"
	TypeProwSuites   = "ProwSuites"
	TypePullRequests = "PullRequests"
	TypeRepository   = "Repository"
	TypeTeams        = "Teams"
	TypeWorkflows    = "Workflows"
)

// BugsMutation represents an operation that mutates the Bugs nodes in the graph.
type BugsMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	jira_key                   *string
	created_at                 *time.Time
	updated_at                 *time.Time
	resolved_at                *time.Time
	resolved                   *bool
	priority                   *string
	resolution_time            *float64
	addresolution_time         *float64
	status                     *string
	summary                    *string
	url                        *string
	project_key                *string
	assignment_time            *float64
	addassignment_time         *float64
	prioritization_time        *float64
	addprioritization_time     *float64
	days_without_assignee      *float64
	adddays_without_assignee   *float64
	days_without_priority      *float64
	adddays_without_priority   *float64
	days_without_resolution    *float64
	adddays_without_resolution *float64
	days_without_component     *float64
	adddays_without_component  *float64
	labels                     *string
	component                  *string
	assignee                   *string
	age                        *string
	clearedFields              map[string]struct{}
	bugs                       *uuid.UUID
	clearedbugs                bool
	done                       bool
	oldValue                   func(context.Context) (*Bugs, error)
	predicates                 []predicate.Bugs
}

var _ ent.Mutation = (*BugsMutation)(nil)

// bugsOption allows management of the mutation configuration using functional options.
type bugsOption func(*BugsMutation)

// newBugsMutation creates new mutation for the Bugs entity.
func newBugsMutation(c config, op Op, opts ...bugsOption) *BugsMutation {
	m := &BugsMutation{
		config:        c,
		op:            op,
		typ:           TypeBugs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBugsID sets the ID field of the mutation.
func withBugsID(id uuid.UUID) bugsOption {
	return func(m *BugsMutation) {
		var (
			err   error
			once  sync.Once
			value *Bugs
		)
		m.oldValue = func(ctx context.Context) (*Bugs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bugs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBugs sets the old Bugs of the mutation.
func withBugs(node *Bugs) bugsOption {
	return func(m *BugsMutation) {
		m.oldValue = func(context.Context) (*Bugs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BugsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BugsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bugs entities.
func (m *BugsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BugsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BugsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Bugs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJiraKey sets the "jira_key" field.
func (m *BugsMutation) SetJiraKey(s string) {
	m.jira_key = &s
}

// JiraKey returns the value of the "jira_key" field in the mutation.
func (m *BugsMutation) JiraKey() (r string, exists bool) {
	v := m.jira_key
	if v == nil {
		return
	}
	return *v, true
}

// OldJiraKey returns the old "jira_key" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldJiraKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJiraKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJiraKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJiraKey: %w", err)
	}
	return oldValue.JiraKey, nil
}

// ResetJiraKey resets all changes to the "jira_key" field.
func (m *BugsMutation) ResetJiraKey() {
	m.jira_key = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BugsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BugsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BugsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BugsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BugsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BugsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetResolvedAt sets the "resolved_at" field.
func (m *BugsMutation) SetResolvedAt(t time.Time) {
	m.resolved_at = &t
}

// ResolvedAt returns the value of the "resolved_at" field in the mutation.
func (m *BugsMutation) ResolvedAt() (r time.Time, exists bool) {
	v := m.resolved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedAt returns the old "resolved_at" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldResolvedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedAt: %w", err)
	}
	return oldValue.ResolvedAt, nil
}

// ResetResolvedAt resets all changes to the "resolved_at" field.
func (m *BugsMutation) ResetResolvedAt() {
	m.resolved_at = nil
}

// SetResolved sets the "resolved" field.
func (m *BugsMutation) SetResolved(b bool) {
	m.resolved = &b
}

// Resolved returns the value of the "resolved" field in the mutation.
func (m *BugsMutation) Resolved() (r bool, exists bool) {
	v := m.resolved
	if v == nil {
		return
	}
	return *v, true
}

// OldResolved returns the old "resolved" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldResolved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolved: %w", err)
	}
	return oldValue.Resolved, nil
}

// ResetResolved resets all changes to the "resolved" field.
func (m *BugsMutation) ResetResolved() {
	m.resolved = nil
}

// SetPriority sets the "priority" field.
func (m *BugsMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *BugsMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *BugsMutation) ResetPriority() {
	m.priority = nil
}

// SetResolutionTime sets the "resolution_time" field.
func (m *BugsMutation) SetResolutionTime(f float64) {
	m.resolution_time = &f
	m.addresolution_time = nil
}

// ResolutionTime returns the value of the "resolution_time" field in the mutation.
func (m *BugsMutation) ResolutionTime() (r float64, exists bool) {
	v := m.resolution_time
	if v == nil {
		return
	}
	return *v, true
}

// OldResolutionTime returns the old "resolution_time" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldResolutionTime(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolutionTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolutionTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolutionTime: %w", err)
	}
	return oldValue.ResolutionTime, nil
}

// AddResolutionTime adds f to the "resolution_time" field.
func (m *BugsMutation) AddResolutionTime(f float64) {
	if m.addresolution_time != nil {
		*m.addresolution_time += f
	} else {
		m.addresolution_time = &f
	}
}

// AddedResolutionTime returns the value that was added to the "resolution_time" field in this mutation.
func (m *BugsMutation) AddedResolutionTime() (r float64, exists bool) {
	v := m.addresolution_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetResolutionTime resets all changes to the "resolution_time" field.
func (m *BugsMutation) ResetResolutionTime() {
	m.resolution_time = nil
	m.addresolution_time = nil
}

// SetStatus sets the "status" field.
func (m *BugsMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *BugsMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BugsMutation) ResetStatus() {
	m.status = nil
}

// SetSummary sets the "summary" field.
func (m *BugsMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *BugsMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ResetSummary resets all changes to the "summary" field.
func (m *BugsMutation) ResetSummary() {
	m.summary = nil
}

// SetURL sets the "url" field.
func (m *BugsMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *BugsMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *BugsMutation) ResetURL() {
	m.url = nil
}

// SetProjectKey sets the "project_key" field.
func (m *BugsMutation) SetProjectKey(s string) {
	m.project_key = &s
}

// ProjectKey returns the value of the "project_key" field in the mutation.
func (m *BugsMutation) ProjectKey() (r string, exists bool) {
	v := m.project_key
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectKey returns the old "project_key" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldProjectKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectKey: %w", err)
	}
	return oldValue.ProjectKey, nil
}

// ClearProjectKey clears the value of the "project_key" field.
func (m *BugsMutation) ClearProjectKey() {
	m.project_key = nil
	m.clearedFields[bugs.FieldProjectKey] = struct{}{}
}

// ProjectKeyCleared returns if the "project_key" field was cleared in this mutation.
func (m *BugsMutation) ProjectKeyCleared() bool {
	_, ok := m.clearedFields[bugs.FieldProjectKey]
	return ok
}

// ResetProjectKey resets all changes to the "project_key" field.
func (m *BugsMutation) ResetProjectKey() {
	m.project_key = nil
	delete(m.clearedFields, bugs.FieldProjectKey)
}

// SetAssignmentTime sets the "assignment_time" field.
func (m *BugsMutation) SetAssignmentTime(f float64) {
	m.assignment_time = &f
	m.addassignment_time = nil
}

// AssignmentTime returns the value of the "assignment_time" field in the mutation.
func (m *BugsMutation) AssignmentTime() (r float64, exists bool) {
	v := m.assignment_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignmentTime returns the old "assignment_time" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldAssignmentTime(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignmentTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignmentTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignmentTime: %w", err)
	}
	return oldValue.AssignmentTime, nil
}

// AddAssignmentTime adds f to the "assignment_time" field.
func (m *BugsMutation) AddAssignmentTime(f float64) {
	if m.addassignment_time != nil {
		*m.addassignment_time += f
	} else {
		m.addassignment_time = &f
	}
}

// AddedAssignmentTime returns the value that was added to the "assignment_time" field in this mutation.
func (m *BugsMutation) AddedAssignmentTime() (r float64, exists bool) {
	v := m.addassignment_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssignmentTime clears the value of the "assignment_time" field.
func (m *BugsMutation) ClearAssignmentTime() {
	m.assignment_time = nil
	m.addassignment_time = nil
	m.clearedFields[bugs.FieldAssignmentTime] = struct{}{}
}

// AssignmentTimeCleared returns if the "assignment_time" field was cleared in this mutation.
func (m *BugsMutation) AssignmentTimeCleared() bool {
	_, ok := m.clearedFields[bugs.FieldAssignmentTime]
	return ok
}

// ResetAssignmentTime resets all changes to the "assignment_time" field.
func (m *BugsMutation) ResetAssignmentTime() {
	m.assignment_time = nil
	m.addassignment_time = nil
	delete(m.clearedFields, bugs.FieldAssignmentTime)
}

// SetPrioritizationTime sets the "prioritization_time" field.
func (m *BugsMutation) SetPrioritizationTime(f float64) {
	m.prioritization_time = &f
	m.addprioritization_time = nil
}

// PrioritizationTime returns the value of the "prioritization_time" field in the mutation.
func (m *BugsMutation) PrioritizationTime() (r float64, exists bool) {
	v := m.prioritization_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPrioritizationTime returns the old "prioritization_time" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldPrioritizationTime(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrioritizationTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrioritizationTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrioritizationTime: %w", err)
	}
	return oldValue.PrioritizationTime, nil
}

// AddPrioritizationTime adds f to the "prioritization_time" field.
func (m *BugsMutation) AddPrioritizationTime(f float64) {
	if m.addprioritization_time != nil {
		*m.addprioritization_time += f
	} else {
		m.addprioritization_time = &f
	}
}

// AddedPrioritizationTime returns the value that was added to the "prioritization_time" field in this mutation.
func (m *BugsMutation) AddedPrioritizationTime() (r float64, exists bool) {
	v := m.addprioritization_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrioritizationTime clears the value of the "prioritization_time" field.
func (m *BugsMutation) ClearPrioritizationTime() {
	m.prioritization_time = nil
	m.addprioritization_time = nil
	m.clearedFields[bugs.FieldPrioritizationTime] = struct{}{}
}

// PrioritizationTimeCleared returns if the "prioritization_time" field was cleared in this mutation.
func (m *BugsMutation) PrioritizationTimeCleared() bool {
	_, ok := m.clearedFields[bugs.FieldPrioritizationTime]
	return ok
}

// ResetPrioritizationTime resets all changes to the "prioritization_time" field.
func (m *BugsMutation) ResetPrioritizationTime() {
	m.prioritization_time = nil
	m.addprioritization_time = nil
	delete(m.clearedFields, bugs.FieldPrioritizationTime)
}

// SetDaysWithoutAssignee sets the "days_without_assignee" field.
func (m *BugsMutation) SetDaysWithoutAssignee(f float64) {
	m.days_without_assignee = &f
	m.adddays_without_assignee = nil
}

// DaysWithoutAssignee returns the value of the "days_without_assignee" field in the mutation.
func (m *BugsMutation) DaysWithoutAssignee() (r float64, exists bool) {
	v := m.days_without_assignee
	if v == nil {
		return
	}
	return *v, true
}

// OldDaysWithoutAssignee returns the old "days_without_assignee" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldDaysWithoutAssignee(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDaysWithoutAssignee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDaysWithoutAssignee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDaysWithoutAssignee: %w", err)
	}
	return oldValue.DaysWithoutAssignee, nil
}

// AddDaysWithoutAssignee adds f to the "days_without_assignee" field.
func (m *BugsMutation) AddDaysWithoutAssignee(f float64) {
	if m.adddays_without_assignee != nil {
		*m.adddays_without_assignee += f
	} else {
		m.adddays_without_assignee = &f
	}
}

// AddedDaysWithoutAssignee returns the value that was added to the "days_without_assignee" field in this mutation.
func (m *BugsMutation) AddedDaysWithoutAssignee() (r float64, exists bool) {
	v := m.adddays_without_assignee
	if v == nil {
		return
	}
	return *v, true
}

// ClearDaysWithoutAssignee clears the value of the "days_without_assignee" field.
func (m *BugsMutation) ClearDaysWithoutAssignee() {
	m.days_without_assignee = nil
	m.adddays_without_assignee = nil
	m.clearedFields[bugs.FieldDaysWithoutAssignee] = struct{}{}
}

// DaysWithoutAssigneeCleared returns if the "days_without_assignee" field was cleared in this mutation.
func (m *BugsMutation) DaysWithoutAssigneeCleared() bool {
	_, ok := m.clearedFields[bugs.FieldDaysWithoutAssignee]
	return ok
}

// ResetDaysWithoutAssignee resets all changes to the "days_without_assignee" field.
func (m *BugsMutation) ResetDaysWithoutAssignee() {
	m.days_without_assignee = nil
	m.adddays_without_assignee = nil
	delete(m.clearedFields, bugs.FieldDaysWithoutAssignee)
}

// SetDaysWithoutPriority sets the "days_without_priority" field.
func (m *BugsMutation) SetDaysWithoutPriority(f float64) {
	m.days_without_priority = &f
	m.adddays_without_priority = nil
}

// DaysWithoutPriority returns the value of the "days_without_priority" field in the mutation.
func (m *BugsMutation) DaysWithoutPriority() (r float64, exists bool) {
	v := m.days_without_priority
	if v == nil {
		return
	}
	return *v, true
}

// OldDaysWithoutPriority returns the old "days_without_priority" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldDaysWithoutPriority(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDaysWithoutPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDaysWithoutPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDaysWithoutPriority: %w", err)
	}
	return oldValue.DaysWithoutPriority, nil
}

// AddDaysWithoutPriority adds f to the "days_without_priority" field.
func (m *BugsMutation) AddDaysWithoutPriority(f float64) {
	if m.adddays_without_priority != nil {
		*m.adddays_without_priority += f
	} else {
		m.adddays_without_priority = &f
	}
}

// AddedDaysWithoutPriority returns the value that was added to the "days_without_priority" field in this mutation.
func (m *BugsMutation) AddedDaysWithoutPriority() (r float64, exists bool) {
	v := m.adddays_without_priority
	if v == nil {
		return
	}
	return *v, true
}

// ClearDaysWithoutPriority clears the value of the "days_without_priority" field.
func (m *BugsMutation) ClearDaysWithoutPriority() {
	m.days_without_priority = nil
	m.adddays_without_priority = nil
	m.clearedFields[bugs.FieldDaysWithoutPriority] = struct{}{}
}

// DaysWithoutPriorityCleared returns if the "days_without_priority" field was cleared in this mutation.
func (m *BugsMutation) DaysWithoutPriorityCleared() bool {
	_, ok := m.clearedFields[bugs.FieldDaysWithoutPriority]
	return ok
}

// ResetDaysWithoutPriority resets all changes to the "days_without_priority" field.
func (m *BugsMutation) ResetDaysWithoutPriority() {
	m.days_without_priority = nil
	m.adddays_without_priority = nil
	delete(m.clearedFields, bugs.FieldDaysWithoutPriority)
}

// SetDaysWithoutResolution sets the "days_without_resolution" field.
func (m *BugsMutation) SetDaysWithoutResolution(f float64) {
	m.days_without_resolution = &f
	m.adddays_without_resolution = nil
}

// DaysWithoutResolution returns the value of the "days_without_resolution" field in the mutation.
func (m *BugsMutation) DaysWithoutResolution() (r float64, exists bool) {
	v := m.days_without_resolution
	if v == nil {
		return
	}
	return *v, true
}

// OldDaysWithoutResolution returns the old "days_without_resolution" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldDaysWithoutResolution(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDaysWithoutResolution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDaysWithoutResolution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDaysWithoutResolution: %w", err)
	}
	return oldValue.DaysWithoutResolution, nil
}

// AddDaysWithoutResolution adds f to the "days_without_resolution" field.
func (m *BugsMutation) AddDaysWithoutResolution(f float64) {
	if m.adddays_without_resolution != nil {
		*m.adddays_without_resolution += f
	} else {
		m.adddays_without_resolution = &f
	}
}

// AddedDaysWithoutResolution returns the value that was added to the "days_without_resolution" field in this mutation.
func (m *BugsMutation) AddedDaysWithoutResolution() (r float64, exists bool) {
	v := m.adddays_without_resolution
	if v == nil {
		return
	}
	return *v, true
}

// ClearDaysWithoutResolution clears the value of the "days_without_resolution" field.
func (m *BugsMutation) ClearDaysWithoutResolution() {
	m.days_without_resolution = nil
	m.adddays_without_resolution = nil
	m.clearedFields[bugs.FieldDaysWithoutResolution] = struct{}{}
}

// DaysWithoutResolutionCleared returns if the "days_without_resolution" field was cleared in this mutation.
func (m *BugsMutation) DaysWithoutResolutionCleared() bool {
	_, ok := m.clearedFields[bugs.FieldDaysWithoutResolution]
	return ok
}

// ResetDaysWithoutResolution resets all changes to the "days_without_resolution" field.
func (m *BugsMutation) ResetDaysWithoutResolution() {
	m.days_without_resolution = nil
	m.adddays_without_resolution = nil
	delete(m.clearedFields, bugs.FieldDaysWithoutResolution)
}

// SetDaysWithoutComponent sets the "days_without_component" field.
func (m *BugsMutation) SetDaysWithoutComponent(f float64) {
	m.days_without_component = &f
	m.adddays_without_component = nil
}

// DaysWithoutComponent returns the value of the "days_without_component" field in the mutation.
func (m *BugsMutation) DaysWithoutComponent() (r float64, exists bool) {
	v := m.days_without_component
	if v == nil {
		return
	}
	return *v, true
}

// OldDaysWithoutComponent returns the old "days_without_component" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldDaysWithoutComponent(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDaysWithoutComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDaysWithoutComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDaysWithoutComponent: %w", err)
	}
	return oldValue.DaysWithoutComponent, nil
}

// AddDaysWithoutComponent adds f to the "days_without_component" field.
func (m *BugsMutation) AddDaysWithoutComponent(f float64) {
	if m.adddays_without_component != nil {
		*m.adddays_without_component += f
	} else {
		m.adddays_without_component = &f
	}
}

// AddedDaysWithoutComponent returns the value that was added to the "days_without_component" field in this mutation.
func (m *BugsMutation) AddedDaysWithoutComponent() (r float64, exists bool) {
	v := m.adddays_without_component
	if v == nil {
		return
	}
	return *v, true
}

// ClearDaysWithoutComponent clears the value of the "days_without_component" field.
func (m *BugsMutation) ClearDaysWithoutComponent() {
	m.days_without_component = nil
	m.adddays_without_component = nil
	m.clearedFields[bugs.FieldDaysWithoutComponent] = struct{}{}
}

// DaysWithoutComponentCleared returns if the "days_without_component" field was cleared in this mutation.
func (m *BugsMutation) DaysWithoutComponentCleared() bool {
	_, ok := m.clearedFields[bugs.FieldDaysWithoutComponent]
	return ok
}

// ResetDaysWithoutComponent resets all changes to the "days_without_component" field.
func (m *BugsMutation) ResetDaysWithoutComponent() {
	m.days_without_component = nil
	m.adddays_without_component = nil
	delete(m.clearedFields, bugs.FieldDaysWithoutComponent)
}

// SetLabels sets the "labels" field.
func (m *BugsMutation) SetLabels(s string) {
	m.labels = &s
}

// Labels returns the value of the "labels" field in the mutation.
func (m *BugsMutation) Labels() (r string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldLabels(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *BugsMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[bugs.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *BugsMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[bugs.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *BugsMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, bugs.FieldLabels)
}

// SetComponent sets the "component" field.
func (m *BugsMutation) SetComponent(s string) {
	m.component = &s
}

// Component returns the value of the "component" field in the mutation.
func (m *BugsMutation) Component() (r string, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponent returns the old "component" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldComponent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponent: %w", err)
	}
	return oldValue.Component, nil
}

// ClearComponent clears the value of the "component" field.
func (m *BugsMutation) ClearComponent() {
	m.component = nil
	m.clearedFields[bugs.FieldComponent] = struct{}{}
}

// ComponentCleared returns if the "component" field was cleared in this mutation.
func (m *BugsMutation) ComponentCleared() bool {
	_, ok := m.clearedFields[bugs.FieldComponent]
	return ok
}

// ResetComponent resets all changes to the "component" field.
func (m *BugsMutation) ResetComponent() {
	m.component = nil
	delete(m.clearedFields, bugs.FieldComponent)
}

// SetAssignee sets the "assignee" field.
func (m *BugsMutation) SetAssignee(s string) {
	m.assignee = &s
}

// Assignee returns the value of the "assignee" field in the mutation.
func (m *BugsMutation) Assignee() (r string, exists bool) {
	v := m.assignee
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignee returns the old "assignee" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldAssignee(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignee: %w", err)
	}
	return oldValue.Assignee, nil
}

// ClearAssignee clears the value of the "assignee" field.
func (m *BugsMutation) ClearAssignee() {
	m.assignee = nil
	m.clearedFields[bugs.FieldAssignee] = struct{}{}
}

// AssigneeCleared returns if the "assignee" field was cleared in this mutation.
func (m *BugsMutation) AssigneeCleared() bool {
	_, ok := m.clearedFields[bugs.FieldAssignee]
	return ok
}

// ResetAssignee resets all changes to the "assignee" field.
func (m *BugsMutation) ResetAssignee() {
	m.assignee = nil
	delete(m.clearedFields, bugs.FieldAssignee)
}

// SetAge sets the "age" field.
func (m *BugsMutation) SetAge(s string) {
	m.age = &s
}

// Age returns the value of the "age" field in the mutation.
func (m *BugsMutation) Age() (r string, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the Bugs entity.
// If the Bugs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BugsMutation) OldAge(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// ClearAge clears the value of the "age" field.
func (m *BugsMutation) ClearAge() {
	m.age = nil
	m.clearedFields[bugs.FieldAge] = struct{}{}
}

// AgeCleared returns if the "age" field was cleared in this mutation.
func (m *BugsMutation) AgeCleared() bool {
	_, ok := m.clearedFields[bugs.FieldAge]
	return ok
}

// ResetAge resets all changes to the "age" field.
func (m *BugsMutation) ResetAge() {
	m.age = nil
	delete(m.clearedFields, bugs.FieldAge)
}

// SetBugsID sets the "bugs" edge to the Teams entity by id.
func (m *BugsMutation) SetBugsID(id uuid.UUID) {
	m.bugs = &id
}

// ClearBugs clears the "bugs" edge to the Teams entity.
func (m *BugsMutation) ClearBugs() {
	m.clearedbugs = true
}

// BugsCleared reports if the "bugs" edge to the Teams entity was cleared.
func (m *BugsMutation) BugsCleared() bool {
	return m.clearedbugs
}

// BugsID returns the "bugs" edge ID in the mutation.
func (m *BugsMutation) BugsID() (id uuid.UUID, exists bool) {
	if m.bugs != nil {
		return *m.bugs, true
	}
	return
}

// BugsIDs returns the "bugs" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BugsID instead. It exists only for internal usage by the builders.
func (m *BugsMutation) BugsIDs() (ids []uuid.UUID) {
	if id := m.bugs; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBugs resets all changes to the "bugs" edge.
func (m *BugsMutation) ResetBugs() {
	m.bugs = nil
	m.clearedbugs = false
}

// Where appends a list predicates to the BugsMutation builder.
func (m *BugsMutation) Where(ps ...predicate.Bugs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BugsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BugsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Bugs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BugsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BugsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Bugs).
func (m *BugsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BugsMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.jira_key != nil {
		fields = append(fields, bugs.FieldJiraKey)
	}
	if m.created_at != nil {
		fields = append(fields, bugs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bugs.FieldUpdatedAt)
	}
	if m.resolved_at != nil {
		fields = append(fields, bugs.FieldResolvedAt)
	}
	if m.resolved != nil {
		fields = append(fields, bugs.FieldResolved)
	}
	if m.priority != nil {
		fields = append(fields, bugs.FieldPriority)
	}
	if m.resolution_time != nil {
		fields = append(fields, bugs.FieldResolutionTime)
	}
	if m.status != nil {
		fields = append(fields, bugs.FieldStatus)
	}
	if m.summary != nil {
		fields = append(fields, bugs.FieldSummary)
	}
	if m.url != nil {
		fields = append(fields, bugs.FieldURL)
	}
	if m.project_key != nil {
		fields = append(fields, bugs.FieldProjectKey)
	}
	if m.assignment_time != nil {
		fields = append(fields, bugs.FieldAssignmentTime)
	}
	if m.prioritization_time != nil {
		fields = append(fields, bugs.FieldPrioritizationTime)
	}
	if m.days_without_assignee != nil {
		fields = append(fields, bugs.FieldDaysWithoutAssignee)
	}
	if m.days_without_priority != nil {
		fields = append(fields, bugs.FieldDaysWithoutPriority)
	}
	if m.days_without_resolution != nil {
		fields = append(fields, bugs.FieldDaysWithoutResolution)
	}
	if m.days_without_component != nil {
		fields = append(fields, bugs.FieldDaysWithoutComponent)
	}
	if m.labels != nil {
		fields = append(fields, bugs.FieldLabels)
	}
	if m.component != nil {
		fields = append(fields, bugs.FieldComponent)
	}
	if m.assignee != nil {
		fields = append(fields, bugs.FieldAssignee)
	}
	if m.age != nil {
		fields = append(fields, bugs.FieldAge)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BugsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bugs.FieldJiraKey:
		return m.JiraKey()
	case bugs.FieldCreatedAt:
		return m.CreatedAt()
	case bugs.FieldUpdatedAt:
		return m.UpdatedAt()
	case bugs.FieldResolvedAt:
		return m.ResolvedAt()
	case bugs.FieldResolved:
		return m.Resolved()
	case bugs.FieldPriority:
		return m.Priority()
	case bugs.FieldResolutionTime:
		return m.ResolutionTime()
	case bugs.FieldStatus:
		return m.Status()
	case bugs.FieldSummary:
		return m.Summary()
	case bugs.FieldURL:
		return m.URL()
	case bugs.FieldProjectKey:
		return m.ProjectKey()
	case bugs.FieldAssignmentTime:
		return m.AssignmentTime()
	case bugs.FieldPrioritizationTime:
		return m.PrioritizationTime()
	case bugs.FieldDaysWithoutAssignee:
		return m.DaysWithoutAssignee()
	case bugs.FieldDaysWithoutPriority:
		return m.DaysWithoutPriority()
	case bugs.FieldDaysWithoutResolution:
		return m.DaysWithoutResolution()
	case bugs.FieldDaysWithoutComponent:
		return m.DaysWithoutComponent()
	case bugs.FieldLabels:
		return m.Labels()
	case bugs.FieldComponent:
		return m.Component()
	case bugs.FieldAssignee:
		return m.Assignee()
	case bugs.FieldAge:
		return m.Age()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BugsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bugs.FieldJiraKey:
		return m.OldJiraKey(ctx)
	case bugs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bugs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case bugs.FieldResolvedAt:
		return m.OldResolvedAt(ctx)
	case bugs.FieldResolved:
		return m.OldResolved(ctx)
	case bugs.FieldPriority:
		return m.OldPriority(ctx)
	case bugs.FieldResolutionTime:
		return m.OldResolutionTime(ctx)
	case bugs.FieldStatus:
		return m.OldStatus(ctx)
	case bugs.FieldSummary:
		return m.OldSummary(ctx)
	case bugs.FieldURL:
		return m.OldURL(ctx)
	case bugs.FieldProjectKey:
		return m.OldProjectKey(ctx)
	case bugs.FieldAssignmentTime:
		return m.OldAssignmentTime(ctx)
	case bugs.FieldPrioritizationTime:
		return m.OldPrioritizationTime(ctx)
	case bugs.FieldDaysWithoutAssignee:
		return m.OldDaysWithoutAssignee(ctx)
	case bugs.FieldDaysWithoutPriority:
		return m.OldDaysWithoutPriority(ctx)
	case bugs.FieldDaysWithoutResolution:
		return m.OldDaysWithoutResolution(ctx)
	case bugs.FieldDaysWithoutComponent:
		return m.OldDaysWithoutComponent(ctx)
	case bugs.FieldLabels:
		return m.OldLabels(ctx)
	case bugs.FieldComponent:
		return m.OldComponent(ctx)
	case bugs.FieldAssignee:
		return m.OldAssignee(ctx)
	case bugs.FieldAge:
		return m.OldAge(ctx)
	}
	return nil, fmt.Errorf("unknown Bugs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BugsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bugs.FieldJiraKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJiraKey(v)
		return nil
	case bugs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bugs.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case bugs.FieldResolvedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedAt(v)
		return nil
	case bugs.FieldResolved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolved(v)
		return nil
	case bugs.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case bugs.FieldResolutionTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolutionTime(v)
		return nil
	case bugs.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case bugs.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case bugs.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case bugs.FieldProjectKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectKey(v)
		return nil
	case bugs.FieldAssignmentTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignmentTime(v)
		return nil
	case bugs.FieldPrioritizationTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrioritizationTime(v)
		return nil
	case bugs.FieldDaysWithoutAssignee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDaysWithoutAssignee(v)
		return nil
	case bugs.FieldDaysWithoutPriority:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDaysWithoutPriority(v)
		return nil
	case bugs.FieldDaysWithoutResolution:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDaysWithoutResolution(v)
		return nil
	case bugs.FieldDaysWithoutComponent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDaysWithoutComponent(v)
		return nil
	case bugs.FieldLabels:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case bugs.FieldComponent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponent(v)
		return nil
	case bugs.FieldAssignee:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignee(v)
		return nil
	case bugs.FieldAge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	}
	return fmt.Errorf("unknown Bugs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BugsMutation) AddedFields() []string {
	var fields []string
	if m.addresolution_time != nil {
		fields = append(fields, bugs.FieldResolutionTime)
	}
	if m.addassignment_time != nil {
		fields = append(fields, bugs.FieldAssignmentTime)
	}
	if m.addprioritization_time != nil {
		fields = append(fields, bugs.FieldPrioritizationTime)
	}
	if m.adddays_without_assignee != nil {
		fields = append(fields, bugs.FieldDaysWithoutAssignee)
	}
	if m.adddays_without_priority != nil {
		fields = append(fields, bugs.FieldDaysWithoutPriority)
	}
	if m.adddays_without_resolution != nil {
		fields = append(fields, bugs.FieldDaysWithoutResolution)
	}
	if m.adddays_without_component != nil {
		fields = append(fields, bugs.FieldDaysWithoutComponent)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BugsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bugs.FieldResolutionTime:
		return m.AddedResolutionTime()
	case bugs.FieldAssignmentTime:
		return m.AddedAssignmentTime()
	case bugs.FieldPrioritizationTime:
		return m.AddedPrioritizationTime()
	case bugs.FieldDaysWithoutAssignee:
		return m.AddedDaysWithoutAssignee()
	case bugs.FieldDaysWithoutPriority:
		return m.AddedDaysWithoutPriority()
	case bugs.FieldDaysWithoutResolution:
		return m.AddedDaysWithoutResolution()
	case bugs.FieldDaysWithoutComponent:
		return m.AddedDaysWithoutComponent()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BugsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bugs.FieldResolutionTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResolutionTime(v)
		return nil
	case bugs.FieldAssignmentTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssignmentTime(v)
		return nil
	case bugs.FieldPrioritizationTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrioritizationTime(v)
		return nil
	case bugs.FieldDaysWithoutAssignee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDaysWithoutAssignee(v)
		return nil
	case bugs.FieldDaysWithoutPriority:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDaysWithoutPriority(v)
		return nil
	case bugs.FieldDaysWithoutResolution:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDaysWithoutResolution(v)
		return nil
	case bugs.FieldDaysWithoutComponent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDaysWithoutComponent(v)
		return nil
	}
	return fmt.Errorf("unknown Bugs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BugsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bugs.FieldProjectKey) {
		fields = append(fields, bugs.FieldProjectKey)
	}
	if m.FieldCleared(bugs.FieldAssignmentTime) {
		fields = append(fields, bugs.FieldAssignmentTime)
	}
	if m.FieldCleared(bugs.FieldPrioritizationTime) {
		fields = append(fields, bugs.FieldPrioritizationTime)
	}
	if m.FieldCleared(bugs.FieldDaysWithoutAssignee) {
		fields = append(fields, bugs.FieldDaysWithoutAssignee)
	}
	if m.FieldCleared(bugs.FieldDaysWithoutPriority) {
		fields = append(fields, bugs.FieldDaysWithoutPriority)
	}
	if m.FieldCleared(bugs.FieldDaysWithoutResolution) {
		fields = append(fields, bugs.FieldDaysWithoutResolution)
	}
	if m.FieldCleared(bugs.FieldDaysWithoutComponent) {
		fields = append(fields, bugs.FieldDaysWithoutComponent)
	}
	if m.FieldCleared(bugs.FieldLabels) {
		fields = append(fields, bugs.FieldLabels)
	}
	if m.FieldCleared(bugs.FieldComponent) {
		fields = append(fields, bugs.FieldComponent)
	}
	if m.FieldCleared(bugs.FieldAssignee) {
		fields = append(fields, bugs.FieldAssignee)
	}
	if m.FieldCleared(bugs.FieldAge) {
		fields = append(fields, bugs.FieldAge)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BugsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BugsMutation) ClearField(name string) error {
	switch name {
	case bugs.FieldProjectKey:
		m.ClearProjectKey()
		return nil
	case bugs.FieldAssignmentTime:
		m.ClearAssignmentTime()
		return nil
	case bugs.FieldPrioritizationTime:
		m.ClearPrioritizationTime()
		return nil
	case bugs.FieldDaysWithoutAssignee:
		m.ClearDaysWithoutAssignee()
		return nil
	case bugs.FieldDaysWithoutPriority:
		m.ClearDaysWithoutPriority()
		return nil
	case bugs.FieldDaysWithoutResolution:
		m.ClearDaysWithoutResolution()
		return nil
	case bugs.FieldDaysWithoutComponent:
		m.ClearDaysWithoutComponent()
		return nil
	case bugs.FieldLabels:
		m.ClearLabels()
		return nil
	case bugs.FieldComponent:
		m.ClearComponent()
		return nil
	case bugs.FieldAssignee:
		m.ClearAssignee()
		return nil
	case bugs.FieldAge:
		m.ClearAge()
		return nil
	}
	return fmt.Errorf("unknown Bugs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BugsMutation) ResetField(name string) error {
	switch name {
	case bugs.FieldJiraKey:
		m.ResetJiraKey()
		return nil
	case bugs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bugs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case bugs.FieldResolvedAt:
		m.ResetResolvedAt()
		return nil
	case bugs.FieldResolved:
		m.ResetResolved()
		return nil
	case bugs.FieldPriority:
		m.ResetPriority()
		return nil
	case bugs.FieldResolutionTime:
		m.ResetResolutionTime()
		return nil
	case bugs.FieldStatus:
		m.ResetStatus()
		return nil
	case bugs.FieldSummary:
		m.ResetSummary()
		return nil
	case bugs.FieldURL:
		m.ResetURL()
		return nil
	case bugs.FieldProjectKey:
		m.ResetProjectKey()
		return nil
	case bugs.FieldAssignmentTime:
		m.ResetAssignmentTime()
		return nil
	case bugs.FieldPrioritizationTime:
		m.ResetPrioritizationTime()
		return nil
	case bugs.FieldDaysWithoutAssignee:
		m.ResetDaysWithoutAssignee()
		return nil
	case bugs.FieldDaysWithoutPriority:
		m.ResetDaysWithoutPriority()
		return nil
	case bugs.FieldDaysWithoutResolution:
		m.ResetDaysWithoutResolution()
		return nil
	case bugs.FieldDaysWithoutComponent:
		m.ResetDaysWithoutComponent()
		return nil
	case bugs.FieldLabels:
		m.ResetLabels()
		return nil
	case bugs.FieldComponent:
		m.ResetComponent()
		return nil
	case bugs.FieldAssignee:
		m.ResetAssignee()
		return nil
	case bugs.FieldAge:
		m.ResetAge()
		return nil
	}
	return fmt.Errorf("unknown Bugs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BugsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bugs != nil {
		edges = append(edges, bugs.EdgeBugs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BugsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bugs.EdgeBugs:
		if id := m.bugs; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BugsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BugsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BugsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbugs {
		edges = append(edges, bugs.EdgeBugs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BugsMutation) EdgeCleared(name string) bool {
	switch name {
	case bugs.EdgeBugs:
		return m.clearedbugs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BugsMutation) ClearEdge(name string) error {
	switch name {
	case bugs.EdgeBugs:
		m.ClearBugs()
		return nil
	}
	return fmt.Errorf("unknown Bugs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BugsMutation) ResetEdge(name string) error {
	switch name {
	case bugs.EdgeBugs:
		m.ResetBugs()
		return nil
	}
	return fmt.Errorf("unknown Bugs edge %s", name)
}

// CodeCovMutation represents an operation that mutates the CodeCov nodes in the graph.
type CodeCovMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	repository_name             *string
	git_organization            *string
	coverage_percentage         *float64
	addcoverage_percentage      *float64
	average_retests             *float64
	addaverage_retests          *float64
	average_retests_to_merge    *float64
	addaverage_retests_to_merge *float64
	coverage_trend              *string
	clearedFields               map[string]struct{}
	codecov                     *string
	clearedcodecov              bool
	done                        bool
	oldValue                    func(context.Context) (*CodeCov, error)
	predicates                  []predicate.CodeCov
}

var _ ent.Mutation = (*CodeCovMutation)(nil)

// codecovOption allows management of the mutation configuration using functional options.
type codecovOption func(*CodeCovMutation)

// newCodeCovMutation creates new mutation for the CodeCov entity.
func newCodeCovMutation(c config, op Op, opts ...codecovOption) *CodeCovMutation {
	m := &CodeCovMutation{
		config:        c,
		op:            op,
		typ:           TypeCodeCov,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodeCovID sets the ID field of the mutation.
func withCodeCovID(id uuid.UUID) codecovOption {
	return func(m *CodeCovMutation) {
		var (
			err   error
			once  sync.Once
			value *CodeCov
		)
		m.oldValue = func(ctx context.Context) (*CodeCov, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodeCov.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodeCov sets the old CodeCov of the mutation.
func withCodeCov(node *CodeCov) codecovOption {
	return func(m *CodeCovMutation) {
		m.oldValue = func(context.Context) (*CodeCov, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodeCovMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodeCovMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CodeCov entities.
func (m *CodeCovMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodeCovMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CodeCovMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CodeCov.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRepositoryName sets the "repository_name" field.
func (m *CodeCovMutation) SetRepositoryName(s string) {
	m.repository_name = &s
}

// RepositoryName returns the value of the "repository_name" field in the mutation.
func (m *CodeCovMutation) RepositoryName() (r string, exists bool) {
	v := m.repository_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRepositoryName returns the old "repository_name" field's value of the CodeCov entity.
// If the CodeCov object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeCovMutation) OldRepositoryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepositoryName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepositoryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepositoryName: %w", err)
	}
	return oldValue.RepositoryName, nil
}

// ResetRepositoryName resets all changes to the "repository_name" field.
func (m *CodeCovMutation) ResetRepositoryName() {
	m.repository_name = nil
}

// SetGitOrganization sets the "git_organization" field.
func (m *CodeCovMutation) SetGitOrganization(s string) {
	m.git_organization = &s
}

// GitOrganization returns the value of the "git_organization" field in the mutation.
func (m *CodeCovMutation) GitOrganization() (r string, exists bool) {
	v := m.git_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldGitOrganization returns the old "git_organization" field's value of the CodeCov entity.
// If the CodeCov object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeCovMutation) OldGitOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitOrganization: %w", err)
	}
	return oldValue.GitOrganization, nil
}

// ResetGitOrganization resets all changes to the "git_organization" field.
func (m *CodeCovMutation) ResetGitOrganization() {
	m.git_organization = nil
}

// SetCoveragePercentage sets the "coverage_percentage" field.
func (m *CodeCovMutation) SetCoveragePercentage(f float64) {
	m.coverage_percentage = &f
	m.addcoverage_percentage = nil
}

// CoveragePercentage returns the value of the "coverage_percentage" field in the mutation.
func (m *CodeCovMutation) CoveragePercentage() (r float64, exists bool) {
	v := m.coverage_percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldCoveragePercentage returns the old "coverage_percentage" field's value of the CodeCov entity.
// If the CodeCov object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeCovMutation) OldCoveragePercentage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoveragePercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoveragePercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoveragePercentage: %w", err)
	}
	return oldValue.CoveragePercentage, nil
}

// AddCoveragePercentage adds f to the "coverage_percentage" field.
func (m *CodeCovMutation) AddCoveragePercentage(f float64) {
	if m.addcoverage_percentage != nil {
		*m.addcoverage_percentage += f
	} else {
		m.addcoverage_percentage = &f
	}
}

// AddedCoveragePercentage returns the value that was added to the "coverage_percentage" field in this mutation.
func (m *CodeCovMutation) AddedCoveragePercentage() (r float64, exists bool) {
	v := m.addcoverage_percentage
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoveragePercentage resets all changes to the "coverage_percentage" field.
func (m *CodeCovMutation) ResetCoveragePercentage() {
	m.coverage_percentage = nil
	m.addcoverage_percentage = nil
}

// SetAverageRetests sets the "average_retests" field.
func (m *CodeCovMutation) SetAverageRetests(f float64) {
	m.average_retests = &f
	m.addaverage_retests = nil
}

// AverageRetests returns the value of the "average_retests" field in the mutation.
func (m *CodeCovMutation) AverageRetests() (r float64, exists bool) {
	v := m.average_retests
	if v == nil {
		return
	}
	return *v, true
}

// OldAverageRetests returns the old "average_retests" field's value of the CodeCov entity.
// If the CodeCov object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeCovMutation) OldAverageRetests(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAverageRetests is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAverageRetests requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAverageRetests: %w", err)
	}
	return oldValue.AverageRetests, nil
}

// AddAverageRetests adds f to the "average_retests" field.
func (m *CodeCovMutation) AddAverageRetests(f float64) {
	if m.addaverage_retests != nil {
		*m.addaverage_retests += f
	} else {
		m.addaverage_retests = &f
	}
}

// AddedAverageRetests returns the value that was added to the "average_retests" field in this mutation.
func (m *CodeCovMutation) AddedAverageRetests() (r float64, exists bool) {
	v := m.addaverage_retests
	if v == nil {
		return
	}
	return *v, true
}

// ClearAverageRetests clears the value of the "average_retests" field.
func (m *CodeCovMutation) ClearAverageRetests() {
	m.average_retests = nil
	m.addaverage_retests = nil
	m.clearedFields[codecov.FieldAverageRetests] = struct{}{}
}

// AverageRetestsCleared returns if the "average_retests" field was cleared in this mutation.
func (m *CodeCovMutation) AverageRetestsCleared() bool {
	_, ok := m.clearedFields[codecov.FieldAverageRetests]
	return ok
}

// ResetAverageRetests resets all changes to the "average_retests" field.
func (m *CodeCovMutation) ResetAverageRetests() {
	m.average_retests = nil
	m.addaverage_retests = nil
	delete(m.clearedFields, codecov.FieldAverageRetests)
}

// SetAverageRetestsToMerge sets the "average_retests_to_merge" field.
func (m *CodeCovMutation) SetAverageRetestsToMerge(f float64) {
	m.average_retests_to_merge = &f
	m.addaverage_retests_to_merge = nil
}

// AverageRetestsToMerge returns the value of the "average_retests_to_merge" field in the mutation.
func (m *CodeCovMutation) AverageRetestsToMerge() (r float64, exists bool) {
	v := m.average_retests_to_merge
	if v == nil {
		return
	}
	return *v, true
}

// OldAverageRetestsToMerge returns the old "average_retests_to_merge" field's value of the CodeCov entity.
// If the CodeCov object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeCovMutation) OldAverageRetestsToMerge(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAverageRetestsToMerge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAverageRetestsToMerge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAverageRetestsToMerge: %w", err)
	}
	return oldValue.AverageRetestsToMerge, nil
}

// AddAverageRetestsToMerge adds f to the "average_retests_to_merge" field.
func (m *CodeCovMutation) AddAverageRetestsToMerge(f float64) {
	if m.addaverage_retests_to_merge != nil {
		*m.addaverage_retests_to_merge += f
	} else {
		m.addaverage_retests_to_merge = &f
	}
}

// AddedAverageRetestsToMerge returns the value that was added to the "average_retests_to_merge" field in this mutation.
func (m *CodeCovMutation) AddedAverageRetestsToMerge() (r float64, exists bool) {
	v := m.addaverage_retests_to_merge
	if v == nil {
		return
	}
	return *v, true
}

// ClearAverageRetestsToMerge clears the value of the "average_retests_to_merge" field.
func (m *CodeCovMutation) ClearAverageRetestsToMerge() {
	m.average_retests_to_merge = nil
	m.addaverage_retests_to_merge = nil
	m.clearedFields[codecov.FieldAverageRetestsToMerge] = struct{}{}
}

// AverageRetestsToMergeCleared returns if the "average_retests_to_merge" field was cleared in this mutation.
func (m *CodeCovMutation) AverageRetestsToMergeCleared() bool {
	_, ok := m.clearedFields[codecov.FieldAverageRetestsToMerge]
	return ok
}

// ResetAverageRetestsToMerge resets all changes to the "average_retests_to_merge" field.
func (m *CodeCovMutation) ResetAverageRetestsToMerge() {
	m.average_retests_to_merge = nil
	m.addaverage_retests_to_merge = nil
	delete(m.clearedFields, codecov.FieldAverageRetestsToMerge)
}

// SetCoverageTrend sets the "coverage_trend" field.
func (m *CodeCovMutation) SetCoverageTrend(s string) {
	m.coverage_trend = &s
}

// CoverageTrend returns the value of the "coverage_trend" field in the mutation.
func (m *CodeCovMutation) CoverageTrend() (r string, exists bool) {
	v := m.coverage_trend
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverageTrend returns the old "coverage_trend" field's value of the CodeCov entity.
// If the CodeCov object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeCovMutation) OldCoverageTrend(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverageTrend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverageTrend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverageTrend: %w", err)
	}
	return oldValue.CoverageTrend, nil
}

// ClearCoverageTrend clears the value of the "coverage_trend" field.
func (m *CodeCovMutation) ClearCoverageTrend() {
	m.coverage_trend = nil
	m.clearedFields[codecov.FieldCoverageTrend] = struct{}{}
}

// CoverageTrendCleared returns if the "coverage_trend" field was cleared in this mutation.
func (m *CodeCovMutation) CoverageTrendCleared() bool {
	_, ok := m.clearedFields[codecov.FieldCoverageTrend]
	return ok
}

// ResetCoverageTrend resets all changes to the "coverage_trend" field.
func (m *CodeCovMutation) ResetCoverageTrend() {
	m.coverage_trend = nil
	delete(m.clearedFields, codecov.FieldCoverageTrend)
}

// SetCodecovID sets the "codecov" edge to the Repository entity by id.
func (m *CodeCovMutation) SetCodecovID(id string) {
	m.codecov = &id
}

// ClearCodecov clears the "codecov" edge to the Repository entity.
func (m *CodeCovMutation) ClearCodecov() {
	m.clearedcodecov = true
}

// CodecovCleared reports if the "codecov" edge to the Repository entity was cleared.
func (m *CodeCovMutation) CodecovCleared() bool {
	return m.clearedcodecov
}

// CodecovID returns the "codecov" edge ID in the mutation.
func (m *CodeCovMutation) CodecovID() (id string, exists bool) {
	if m.codecov != nil {
		return *m.codecov, true
	}
	return
}

// CodecovIDs returns the "codecov" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CodecovID instead. It exists only for internal usage by the builders.
func (m *CodeCovMutation) CodecovIDs() (ids []string) {
	if id := m.codecov; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCodecov resets all changes to the "codecov" edge.
func (m *CodeCovMutation) ResetCodecov() {
	m.codecov = nil
	m.clearedcodecov = false
}

// Where appends a list predicates to the CodeCovMutation builder.
func (m *CodeCovMutation) Where(ps ...predicate.CodeCov) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CodeCovMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CodeCovMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CodeCov, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CodeCovMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CodeCovMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CodeCov).
func (m *CodeCovMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodeCovMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.repository_name != nil {
		fields = append(fields, codecov.FieldRepositoryName)
	}
	if m.git_organization != nil {
		fields = append(fields, codecov.FieldGitOrganization)
	}
	if m.coverage_percentage != nil {
		fields = append(fields, codecov.FieldCoveragePercentage)
	}
	if m.average_retests != nil {
		fields = append(fields, codecov.FieldAverageRetests)
	}
	if m.average_retests_to_merge != nil {
		fields = append(fields, codecov.FieldAverageRetestsToMerge)
	}
	if m.coverage_trend != nil {
		fields = append(fields, codecov.FieldCoverageTrend)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodeCovMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codecov.FieldRepositoryName:
		return m.RepositoryName()
	case codecov.FieldGitOrganization:
		return m.GitOrganization()
	case codecov.FieldCoveragePercentage:
		return m.CoveragePercentage()
	case codecov.FieldAverageRetests:
		return m.AverageRetests()
	case codecov.FieldAverageRetestsToMerge:
		return m.AverageRetestsToMerge()
	case codecov.FieldCoverageTrend:
		return m.CoverageTrend()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodeCovMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codecov.FieldRepositoryName:
		return m.OldRepositoryName(ctx)
	case codecov.FieldGitOrganization:
		return m.OldGitOrganization(ctx)
	case codecov.FieldCoveragePercentage:
		return m.OldCoveragePercentage(ctx)
	case codecov.FieldAverageRetests:
		return m.OldAverageRetests(ctx)
	case codecov.FieldAverageRetestsToMerge:
		return m.OldAverageRetestsToMerge(ctx)
	case codecov.FieldCoverageTrend:
		return m.OldCoverageTrend(ctx)
	}
	return nil, fmt.Errorf("unknown CodeCov field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodeCovMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codecov.FieldRepositoryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepositoryName(v)
		return nil
	case codecov.FieldGitOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitOrganization(v)
		return nil
	case codecov.FieldCoveragePercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoveragePercentage(v)
		return nil
	case codecov.FieldAverageRetests:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAverageRetests(v)
		return nil
	case codecov.FieldAverageRetestsToMerge:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAverageRetestsToMerge(v)
		return nil
	case codecov.FieldCoverageTrend:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverageTrend(v)
		return nil
	}
	return fmt.Errorf("unknown CodeCov field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodeCovMutation) AddedFields() []string {
	var fields []string
	if m.addcoverage_percentage != nil {
		fields = append(fields, codecov.FieldCoveragePercentage)
	}
	if m.addaverage_retests != nil {
		fields = append(fields, codecov.FieldAverageRetests)
	}
	if m.addaverage_retests_to_merge != nil {
		fields = append(fields, codecov.FieldAverageRetestsToMerge)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodeCovMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case codecov.FieldCoveragePercentage:
		return m.AddedCoveragePercentage()
	case codecov.FieldAverageRetests:
		return m.AddedAverageRetests()
	case codecov.FieldAverageRetestsToMerge:
		return m.AddedAverageRetestsToMerge()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodeCovMutation) AddField(name string, value ent.Value) error {
	switch name {
	case codecov.FieldCoveragePercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoveragePercentage(v)
		return nil
	case codecov.FieldAverageRetests:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAverageRetests(v)
		return nil
	case codecov.FieldAverageRetestsToMerge:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAverageRetestsToMerge(v)
		return nil
	}
	return fmt.Errorf("unknown CodeCov numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodeCovMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(codecov.FieldAverageRetests) {
		fields = append(fields, codecov.FieldAverageRetests)
	}
	if m.FieldCleared(codecov.FieldAverageRetestsToMerge) {
		fields = append(fields, codecov.FieldAverageRetestsToMerge)
	}
	if m.FieldCleared(codecov.FieldCoverageTrend) {
		fields = append(fields, codecov.FieldCoverageTrend)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodeCovMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodeCovMutation) ClearField(name string) error {
	switch name {
	case codecov.FieldAverageRetests:
		m.ClearAverageRetests()
		return nil
	case codecov.FieldAverageRetestsToMerge:
		m.ClearAverageRetestsToMerge()
		return nil
	case codecov.FieldCoverageTrend:
		m.ClearCoverageTrend()
		return nil
	}
	return fmt.Errorf("unknown CodeCov nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodeCovMutation) ResetField(name string) error {
	switch name {
	case codecov.FieldRepositoryName:
		m.ResetRepositoryName()
		return nil
	case codecov.FieldGitOrganization:
		m.ResetGitOrganization()
		return nil
	case codecov.FieldCoveragePercentage:
		m.ResetCoveragePercentage()
		return nil
	case codecov.FieldAverageRetests:
		m.ResetAverageRetests()
		return nil
	case codecov.FieldAverageRetestsToMerge:
		m.ResetAverageRetestsToMerge()
		return nil
	case codecov.FieldCoverageTrend:
		m.ResetCoverageTrend()
		return nil
	}
	return fmt.Errorf("unknown CodeCov field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodeCovMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.codecov != nil {
		edges = append(edges, codecov.EdgeCodecov)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodeCovMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codecov.EdgeCodecov:
		if id := m.codecov; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodeCovMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodeCovMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodeCovMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcodecov {
		edges = append(edges, codecov.EdgeCodecov)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodeCovMutation) EdgeCleared(name string) bool {
	switch name {
	case codecov.EdgeCodecov:
		return m.clearedcodecov
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodeCovMutation) ClearEdge(name string) error {
	switch name {
	case codecov.EdgeCodecov:
		m.ClearCodecov()
		return nil
	}
	return fmt.Errorf("unknown CodeCov unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodeCovMutation) ResetEdge(name string) error {
	switch name {
	case codecov.EdgeCodecov:
		m.ResetCodecov()
		return nil
	}
	return fmt.Errorf("unknown CodeCov edge %s", name)
}

// FailureMutation represents an operation that mutates the Failure nodes in the graph.
type FailureMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	jira_key        *string
	jira_status     *string
	error_message   *string
	title_from_jira *string
	created_date    *time.Time
	closed_date     *time.Time
	labels          *string
	clearedFields   map[string]struct{}
	failures        *uuid.UUID
	clearedfailures bool
	done            bool
	oldValue        func(context.Context) (*Failure, error)
	predicates      []predicate.Failure
}

var _ ent.Mutation = (*FailureMutation)(nil)

// failureOption allows management of the mutation configuration using functional options.
type failureOption func(*FailureMutation)

// newFailureMutation creates new mutation for the Failure entity.
func newFailureMutation(c config, op Op, opts ...failureOption) *FailureMutation {
	m := &FailureMutation{
		config:        c,
		op:            op,
		typ:           TypeFailure,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFailureID sets the ID field of the mutation.
func withFailureID(id uuid.UUID) failureOption {
	return func(m *FailureMutation) {
		var (
			err   error
			once  sync.Once
			value *Failure
		)
		m.oldValue = func(ctx context.Context) (*Failure, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Failure.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFailure sets the old Failure of the mutation.
func withFailure(node *Failure) failureOption {
	return func(m *FailureMutation) {
		m.oldValue = func(context.Context) (*Failure, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FailureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FailureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Failure entities.
func (m *FailureMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FailureMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FailureMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Failure.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJiraKey sets the "jira_key" field.
func (m *FailureMutation) SetJiraKey(s string) {
	m.jira_key = &s
}

// JiraKey returns the value of the "jira_key" field in the mutation.
func (m *FailureMutation) JiraKey() (r string, exists bool) {
	v := m.jira_key
	if v == nil {
		return
	}
	return *v, true
}

// OldJiraKey returns the old "jira_key" field's value of the Failure entity.
// If the Failure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FailureMutation) OldJiraKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJiraKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJiraKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJiraKey: %w", err)
	}
	return oldValue.JiraKey, nil
}

// ResetJiraKey resets all changes to the "jira_key" field.
func (m *FailureMutation) ResetJiraKey() {
	m.jira_key = nil
}

// SetJiraStatus sets the "jira_status" field.
func (m *FailureMutation) SetJiraStatus(s string) {
	m.jira_status = &s
}

// JiraStatus returns the value of the "jira_status" field in the mutation.
func (m *FailureMutation) JiraStatus() (r string, exists bool) {
	v := m.jira_status
	if v == nil {
		return
	}
	return *v, true
}

// OldJiraStatus returns the old "jira_status" field's value of the Failure entity.
// If the Failure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FailureMutation) OldJiraStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJiraStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJiraStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJiraStatus: %w", err)
	}
	return oldValue.JiraStatus, nil
}

// ResetJiraStatus resets all changes to the "jira_status" field.
func (m *FailureMutation) ResetJiraStatus() {
	m.jira_status = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *FailureMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *FailureMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Failure entity.
// If the Failure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FailureMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *FailureMutation) ResetErrorMessage() {
	m.error_message = nil
}

// SetTitleFromJira sets the "title_from_jira" field.
func (m *FailureMutation) SetTitleFromJira(s string) {
	m.title_from_jira = &s
}

// TitleFromJira returns the value of the "title_from_jira" field in the mutation.
func (m *FailureMutation) TitleFromJira() (r string, exists bool) {
	v := m.title_from_jira
	if v == nil {
		return
	}
	return *v, true
}

// OldTitleFromJira returns the old "title_from_jira" field's value of the Failure entity.
// If the Failure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FailureMutation) OldTitleFromJira(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitleFromJira is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitleFromJira requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitleFromJira: %w", err)
	}
	return oldValue.TitleFromJira, nil
}

// ClearTitleFromJira clears the value of the "title_from_jira" field.
func (m *FailureMutation) ClearTitleFromJira() {
	m.title_from_jira = nil
	m.clearedFields[failure.FieldTitleFromJira] = struct{}{}
}

// TitleFromJiraCleared returns if the "title_from_jira" field was cleared in this mutation.
func (m *FailureMutation) TitleFromJiraCleared() bool {
	_, ok := m.clearedFields[failure.FieldTitleFromJira]
	return ok
}

// ResetTitleFromJira resets all changes to the "title_from_jira" field.
func (m *FailureMutation) ResetTitleFromJira() {
	m.title_from_jira = nil
	delete(m.clearedFields, failure.FieldTitleFromJira)
}

// SetCreatedDate sets the "created_date" field.
func (m *FailureMutation) SetCreatedDate(t time.Time) {
	m.created_date = &t
}

// CreatedDate returns the value of the "created_date" field in the mutation.
func (m *FailureMutation) CreatedDate() (r time.Time, exists bool) {
	v := m.created_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "created_date" field's value of the Failure entity.
// If the Failure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FailureMutation) OldCreatedDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ClearCreatedDate clears the value of the "created_date" field.
func (m *FailureMutation) ClearCreatedDate() {
	m.created_date = nil
	m.clearedFields[failure.FieldCreatedDate] = struct{}{}
}

// CreatedDateCleared returns if the "created_date" field was cleared in this mutation.
func (m *FailureMutation) CreatedDateCleared() bool {
	_, ok := m.clearedFields[failure.FieldCreatedDate]
	return ok
}

// ResetCreatedDate resets all changes to the "created_date" field.
func (m *FailureMutation) ResetCreatedDate() {
	m.created_date = nil
	delete(m.clearedFields, failure.FieldCreatedDate)
}

// SetClosedDate sets the "closed_date" field.
func (m *FailureMutation) SetClosedDate(t time.Time) {
	m.closed_date = &t
}

// ClosedDate returns the value of the "closed_date" field in the mutation.
func (m *FailureMutation) ClosedDate() (r time.Time, exists bool) {
	v := m.closed_date
	if v == nil {
		return
	}
	return *v, true
}

// OldClosedDate returns the old "closed_date" field's value of the Failure entity.
// If the Failure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FailureMutation) OldClosedDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClosedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClosedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosedDate: %w", err)
	}
	return oldValue.ClosedDate, nil
}

// ClearClosedDate clears the value of the "closed_date" field.
func (m *FailureMutation) ClearClosedDate() {
	m.closed_date = nil
	m.clearedFields[failure.FieldClosedDate] = struct{}{}
}

// ClosedDateCleared returns if the "closed_date" field was cleared in this mutation.
func (m *FailureMutation) ClosedDateCleared() bool {
	_, ok := m.clearedFields[failure.FieldClosedDate]
	return ok
}

// ResetClosedDate resets all changes to the "closed_date" field.
func (m *FailureMutation) ResetClosedDate() {
	m.closed_date = nil
	delete(m.clearedFields, failure.FieldClosedDate)
}

// SetLabels sets the "labels" field.
func (m *FailureMutation) SetLabels(s string) {
	m.labels = &s
}

// Labels returns the value of the "labels" field in the mutation.
func (m *FailureMutation) Labels() (r string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Failure entity.
// If the Failure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FailureMutation) OldLabels(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *FailureMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[failure.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *FailureMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[failure.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *FailureMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, failure.FieldLabels)
}

// SetFailuresID sets the "failures" edge to the Teams entity by id.
func (m *FailureMutation) SetFailuresID(id uuid.UUID) {
	m.failures = &id
}

// ClearFailures clears the "failures" edge to the Teams entity.
func (m *FailureMutation) ClearFailures() {
	m.clearedfailures = true
}

// FailuresCleared reports if the "failures" edge to the Teams entity was cleared.
func (m *FailureMutation) FailuresCleared() bool {
	return m.clearedfailures
}

// FailuresID returns the "failures" edge ID in the mutation.
func (m *FailureMutation) FailuresID() (id uuid.UUID, exists bool) {
	if m.failures != nil {
		return *m.failures, true
	}
	return
}

// FailuresIDs returns the "failures" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FailuresID instead. It exists only for internal usage by the builders.
func (m *FailureMutation) FailuresIDs() (ids []uuid.UUID) {
	if id := m.failures; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFailures resets all changes to the "failures" edge.
func (m *FailureMutation) ResetFailures() {
	m.failures = nil
	m.clearedfailures = false
}

// Where appends a list predicates to the FailureMutation builder.
func (m *FailureMutation) Where(ps ...predicate.Failure) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FailureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FailureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Failure, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FailureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FailureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Failure).
func (m *FailureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FailureMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.jira_key != nil {
		fields = append(fields, failure.FieldJiraKey)
	}
	if m.jira_status != nil {
		fields = append(fields, failure.FieldJiraStatus)
	}
	if m.error_message != nil {
		fields = append(fields, failure.FieldErrorMessage)
	}
	if m.title_from_jira != nil {
		fields = append(fields, failure.FieldTitleFromJira)
	}
	if m.created_date != nil {
		fields = append(fields, failure.FieldCreatedDate)
	}
	if m.closed_date != nil {
		fields = append(fields, failure.FieldClosedDate)
	}
	if m.labels != nil {
		fields = append(fields, failure.FieldLabels)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FailureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case failure.FieldJiraKey:
		return m.JiraKey()
	case failure.FieldJiraStatus:
		return m.JiraStatus()
	case failure.FieldErrorMessage:
		return m.ErrorMessage()
	case failure.FieldTitleFromJira:
		return m.TitleFromJira()
	case failure.FieldCreatedDate:
		return m.CreatedDate()
	case failure.FieldClosedDate:
		return m.ClosedDate()
	case failure.FieldLabels:
		return m.Labels()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FailureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case failure.FieldJiraKey:
		return m.OldJiraKey(ctx)
	case failure.FieldJiraStatus:
		return m.OldJiraStatus(ctx)
	case failure.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case failure.FieldTitleFromJira:
		return m.OldTitleFromJira(ctx)
	case failure.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	case failure.FieldClosedDate:
		return m.OldClosedDate(ctx)
	case failure.FieldLabels:
		return m.OldLabels(ctx)
	}
	return nil, fmt.Errorf("unknown Failure field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FailureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case failure.FieldJiraKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJiraKey(v)
		return nil
	case failure.FieldJiraStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJiraStatus(v)
		return nil
	case failure.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case failure.FieldTitleFromJira:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitleFromJira(v)
		return nil
	case failure.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	case failure.FieldClosedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosedDate(v)
		return nil
	case failure.FieldLabels:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	}
	return fmt.Errorf("unknown Failure field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FailureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FailureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FailureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Failure numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FailureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(failure.FieldTitleFromJira) {
		fields = append(fields, failure.FieldTitleFromJira)
	}
	if m.FieldCleared(failure.FieldCreatedDate) {
		fields = append(fields, failure.FieldCreatedDate)
	}
	if m.FieldCleared(failure.FieldClosedDate) {
		fields = append(fields, failure.FieldClosedDate)
	}
	if m.FieldCleared(failure.FieldLabels) {
		fields = append(fields, failure.FieldLabels)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FailureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FailureMutation) ClearField(name string) error {
	switch name {
	case failure.FieldTitleFromJira:
		m.ClearTitleFromJira()
		return nil
	case failure.FieldCreatedDate:
		m.ClearCreatedDate()
		return nil
	case failure.FieldClosedDate:
		m.ClearClosedDate()
		return nil
	case failure.FieldLabels:
		m.ClearLabels()
		return nil
	}
	return fmt.Errorf("unknown Failure nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FailureMutation) ResetField(name string) error {
	switch name {
	case failure.FieldJiraKey:
		m.ResetJiraKey()
		return nil
	case failure.FieldJiraStatus:
		m.ResetJiraStatus()
		return nil
	case failure.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case failure.FieldTitleFromJira:
		m.ResetTitleFromJira()
		return nil
	case failure.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	case failure.FieldClosedDate:
		m.ResetClosedDate()
		return nil
	case failure.FieldLabels:
		m.ResetLabels()
		return nil
	}
	return fmt.Errorf("unknown Failure field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FailureMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.failures != nil {
		edges = append(edges, failure.EdgeFailures)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FailureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case failure.EdgeFailures:
		if id := m.failures; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FailureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FailureMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FailureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfailures {
		edges = append(edges, failure.EdgeFailures)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FailureMutation) EdgeCleared(name string) bool {
	switch name {
	case failure.EdgeFailures:
		return m.clearedfailures
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FailureMutation) ClearEdge(name string) error {
	switch name {
	case failure.EdgeFailures:
		m.ClearFailures()
		return nil
	}
	return fmt.Errorf("unknown Failure unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FailureMutation) ResetEdge(name string) error {
	switch name {
	case failure.EdgeFailures:
		m.ResetFailures()
		return nil
	}
	return fmt.Errorf("unknown Failure edge %s", name)
}

// ProwJobsMutation represents an operation that mutates the ProwJobs nodes in the graph.
type ProwJobsMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	job_id                   *string
	created_at               *time.Time
	duration                 *float64
	addduration              *float64
	tests_count              *int64
	addtests_count           *int64
	failed_count             *int64
	addfailed_count          *int64
	skipped_count            *int64
	addskipped_count         *int64
	job_name                 *string
	job_type                 *string
	state                    *string
	job_url                  *string
	ci_failed                *int16
	addci_failed             *int16
	external_services_impact *bool
	e2e_failed_test_messages *string
	suites_xml_url           *string
	build_error_logs         *string
	clearedFields            map[string]struct{}
	prow_jobs                *string
	clearedprow_jobs         bool
	done                     bool
	oldValue                 func(context.Context) (*ProwJobs, error)
	predicates               []predicate.ProwJobs
}

var _ ent.Mutation = (*ProwJobsMutation)(nil)

// prowjobsOption allows management of the mutation configuration using functional options.
type prowjobsOption func(*ProwJobsMutation)

// newProwJobsMutation creates new mutation for the ProwJobs entity.
func newProwJobsMutation(c config, op Op, opts ...prowjobsOption) *ProwJobsMutation {
	m := &ProwJobsMutation{
		config:        c,
		op:            op,
		typ:           TypeProwJobs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProwJobsID sets the ID field of the mutation.
func withProwJobsID(id int) prowjobsOption {
	return func(m *ProwJobsMutation) {
		var (
			err   error
			once  sync.Once
			value *ProwJobs
		)
		m.oldValue = func(ctx context.Context) (*ProwJobs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProwJobs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProwJobs sets the old ProwJobs of the mutation.
func withProwJobs(node *ProwJobs) prowjobsOption {
	return func(m *ProwJobsMutation) {
		m.oldValue = func(context.Context) (*ProwJobs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProwJobsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProwJobsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProwJobsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProwJobsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProwJobs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJobID sets the "job_id" field.
func (m *ProwJobsMutation) SetJobID(s string) {
	m.job_id = &s
}

// JobID returns the value of the "job_id" field in the mutation.
func (m *ProwJobsMutation) JobID() (r string, exists bool) {
	v := m.job_id
	if v == nil {
		return
	}
	return *v, true
}

// OldJobID returns the old "job_id" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldJobID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobID: %w", err)
	}
	return oldValue.JobID, nil
}

// ResetJobID resets all changes to the "job_id" field.
func (m *ProwJobsMutation) ResetJobID() {
	m.job_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProwJobsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProwJobsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProwJobsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDuration sets the "duration" field.
func (m *ProwJobsMutation) SetDuration(f float64) {
	m.duration = &f
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *ProwJobsMutation) Duration() (r float64, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldDuration(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds f to the "duration" field.
func (m *ProwJobsMutation) AddDuration(f float64) {
	if m.addduration != nil {
		*m.addduration += f
	} else {
		m.addduration = &f
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *ProwJobsMutation) AddedDuration() (r float64, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *ProwJobsMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetTestsCount sets the "tests_count" field.
func (m *ProwJobsMutation) SetTestsCount(i int64) {
	m.tests_count = &i
	m.addtests_count = nil
}

// TestsCount returns the value of the "tests_count" field in the mutation.
func (m *ProwJobsMutation) TestsCount() (r int64, exists bool) {
	v := m.tests_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTestsCount returns the old "tests_count" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldTestsCount(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestsCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestsCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestsCount: %w", err)
	}
	return oldValue.TestsCount, nil
}

// AddTestsCount adds i to the "tests_count" field.
func (m *ProwJobsMutation) AddTestsCount(i int64) {
	if m.addtests_count != nil {
		*m.addtests_count += i
	} else {
		m.addtests_count = &i
	}
}

// AddedTestsCount returns the value that was added to the "tests_count" field in this mutation.
func (m *ProwJobsMutation) AddedTestsCount() (r int64, exists bool) {
	v := m.addtests_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearTestsCount clears the value of the "tests_count" field.
func (m *ProwJobsMutation) ClearTestsCount() {
	m.tests_count = nil
	m.addtests_count = nil
	m.clearedFields[prowjobs.FieldTestsCount] = struct{}{}
}

// TestsCountCleared returns if the "tests_count" field was cleared in this mutation.
func (m *ProwJobsMutation) TestsCountCleared() bool {
	_, ok := m.clearedFields[prowjobs.FieldTestsCount]
	return ok
}

// ResetTestsCount resets all changes to the "tests_count" field.
func (m *ProwJobsMutation) ResetTestsCount() {
	m.tests_count = nil
	m.addtests_count = nil
	delete(m.clearedFields, prowjobs.FieldTestsCount)
}

// SetFailedCount sets the "failed_count" field.
func (m *ProwJobsMutation) SetFailedCount(i int64) {
	m.failed_count = &i
	m.addfailed_count = nil
}

// FailedCount returns the value of the "failed_count" field in the mutation.
func (m *ProwJobsMutation) FailedCount() (r int64, exists bool) {
	v := m.failed_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFailedCount returns the old "failed_count" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldFailedCount(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailedCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailedCount: %w", err)
	}
	return oldValue.FailedCount, nil
}

// AddFailedCount adds i to the "failed_count" field.
func (m *ProwJobsMutation) AddFailedCount(i int64) {
	if m.addfailed_count != nil {
		*m.addfailed_count += i
	} else {
		m.addfailed_count = &i
	}
}

// AddedFailedCount returns the value that was added to the "failed_count" field in this mutation.
func (m *ProwJobsMutation) AddedFailedCount() (r int64, exists bool) {
	v := m.addfailed_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearFailedCount clears the value of the "failed_count" field.
func (m *ProwJobsMutation) ClearFailedCount() {
	m.failed_count = nil
	m.addfailed_count = nil
	m.clearedFields[prowjobs.FieldFailedCount] = struct{}{}
}

// FailedCountCleared returns if the "failed_count" field was cleared in this mutation.
func (m *ProwJobsMutation) FailedCountCleared() bool {
	_, ok := m.clearedFields[prowjobs.FieldFailedCount]
	return ok
}

// ResetFailedCount resets all changes to the "failed_count" field.
func (m *ProwJobsMutation) ResetFailedCount() {
	m.failed_count = nil
	m.addfailed_count = nil
	delete(m.clearedFields, prowjobs.FieldFailedCount)
}

// SetSkippedCount sets the "skipped_count" field.
func (m *ProwJobsMutation) SetSkippedCount(i int64) {
	m.skipped_count = &i
	m.addskipped_count = nil
}

// SkippedCount returns the value of the "skipped_count" field in the mutation.
func (m *ProwJobsMutation) SkippedCount() (r int64, exists bool) {
	v := m.skipped_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSkippedCount returns the old "skipped_count" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldSkippedCount(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkippedCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkippedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkippedCount: %w", err)
	}
	return oldValue.SkippedCount, nil
}

// AddSkippedCount adds i to the "skipped_count" field.
func (m *ProwJobsMutation) AddSkippedCount(i int64) {
	if m.addskipped_count != nil {
		*m.addskipped_count += i
	} else {
		m.addskipped_count = &i
	}
}

// AddedSkippedCount returns the value that was added to the "skipped_count" field in this mutation.
func (m *ProwJobsMutation) AddedSkippedCount() (r int64, exists bool) {
	v := m.addskipped_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearSkippedCount clears the value of the "skipped_count" field.
func (m *ProwJobsMutation) ClearSkippedCount() {
	m.skipped_count = nil
	m.addskipped_count = nil
	m.clearedFields[prowjobs.FieldSkippedCount] = struct{}{}
}

// SkippedCountCleared returns if the "skipped_count" field was cleared in this mutation.
func (m *ProwJobsMutation) SkippedCountCleared() bool {
	_, ok := m.clearedFields[prowjobs.FieldSkippedCount]
	return ok
}

// ResetSkippedCount resets all changes to the "skipped_count" field.
func (m *ProwJobsMutation) ResetSkippedCount() {
	m.skipped_count = nil
	m.addskipped_count = nil
	delete(m.clearedFields, prowjobs.FieldSkippedCount)
}

// SetJobName sets the "job_name" field.
func (m *ProwJobsMutation) SetJobName(s string) {
	m.job_name = &s
}

// JobName returns the value of the "job_name" field in the mutation.
func (m *ProwJobsMutation) JobName() (r string, exists bool) {
	v := m.job_name
	if v == nil {
		return
	}
	return *v, true
}

// OldJobName returns the old "job_name" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldJobName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobName: %w", err)
	}
	return oldValue.JobName, nil
}

// ResetJobName resets all changes to the "job_name" field.
func (m *ProwJobsMutation) ResetJobName() {
	m.job_name = nil
}

// SetJobType sets the "job_type" field.
func (m *ProwJobsMutation) SetJobType(s string) {
	m.job_type = &s
}

// JobType returns the value of the "job_type" field in the mutation.
func (m *ProwJobsMutation) JobType() (r string, exists bool) {
	v := m.job_type
	if v == nil {
		return
	}
	return *v, true
}

// OldJobType returns the old "job_type" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldJobType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobType: %w", err)
	}
	return oldValue.JobType, nil
}

// ResetJobType resets all changes to the "job_type" field.
func (m *ProwJobsMutation) ResetJobType() {
	m.job_type = nil
}

// SetState sets the "state" field.
func (m *ProwJobsMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *ProwJobsMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *ProwJobsMutation) ResetState() {
	m.state = nil
}

// SetJobURL sets the "job_url" field.
func (m *ProwJobsMutation) SetJobURL(s string) {
	m.job_url = &s
}

// JobURL returns the value of the "job_url" field in the mutation.
func (m *ProwJobsMutation) JobURL() (r string, exists bool) {
	v := m.job_url
	if v == nil {
		return
	}
	return *v, true
}

// OldJobURL returns the old "job_url" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldJobURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobURL: %w", err)
	}
	return oldValue.JobURL, nil
}

// ResetJobURL resets all changes to the "job_url" field.
func (m *ProwJobsMutation) ResetJobURL() {
	m.job_url = nil
}

// SetCiFailed sets the "ci_failed" field.
func (m *ProwJobsMutation) SetCiFailed(i int16) {
	m.ci_failed = &i
	m.addci_failed = nil
}

// CiFailed returns the value of the "ci_failed" field in the mutation.
func (m *ProwJobsMutation) CiFailed() (r int16, exists bool) {
	v := m.ci_failed
	if v == nil {
		return
	}
	return *v, true
}

// OldCiFailed returns the old "ci_failed" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldCiFailed(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCiFailed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCiFailed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCiFailed: %w", err)
	}
	return oldValue.CiFailed, nil
}

// AddCiFailed adds i to the "ci_failed" field.
func (m *ProwJobsMutation) AddCiFailed(i int16) {
	if m.addci_failed != nil {
		*m.addci_failed += i
	} else {
		m.addci_failed = &i
	}
}

// AddedCiFailed returns the value that was added to the "ci_failed" field in this mutation.
func (m *ProwJobsMutation) AddedCiFailed() (r int16, exists bool) {
	v := m.addci_failed
	if v == nil {
		return
	}
	return *v, true
}

// ResetCiFailed resets all changes to the "ci_failed" field.
func (m *ProwJobsMutation) ResetCiFailed() {
	m.ci_failed = nil
	m.addci_failed = nil
}

// SetExternalServicesImpact sets the "external_services_impact" field.
func (m *ProwJobsMutation) SetExternalServicesImpact(b bool) {
	m.external_services_impact = &b
}

// ExternalServicesImpact returns the value of the "external_services_impact" field in the mutation.
func (m *ProwJobsMutation) ExternalServicesImpact() (r bool, exists bool) {
	v := m.external_services_impact
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalServicesImpact returns the old "external_services_impact" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldExternalServicesImpact(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalServicesImpact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalServicesImpact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalServicesImpact: %w", err)
	}
	return oldValue.ExternalServicesImpact, nil
}

// ClearExternalServicesImpact clears the value of the "external_services_impact" field.
func (m *ProwJobsMutation) ClearExternalServicesImpact() {
	m.external_services_impact = nil
	m.clearedFields[prowjobs.FieldExternalServicesImpact] = struct{}{}
}

// ExternalServicesImpactCleared returns if the "external_services_impact" field was cleared in this mutation.
func (m *ProwJobsMutation) ExternalServicesImpactCleared() bool {
	_, ok := m.clearedFields[prowjobs.FieldExternalServicesImpact]
	return ok
}

// ResetExternalServicesImpact resets all changes to the "external_services_impact" field.
func (m *ProwJobsMutation) ResetExternalServicesImpact() {
	m.external_services_impact = nil
	delete(m.clearedFields, prowjobs.FieldExternalServicesImpact)
}

// SetE2eFailedTestMessages sets the "e2e_failed_test_messages" field.
func (m *ProwJobsMutation) SetE2eFailedTestMessages(s string) {
	m.e2e_failed_test_messages = &s
}

// E2eFailedTestMessages returns the value of the "e2e_failed_test_messages" field in the mutation.
func (m *ProwJobsMutation) E2eFailedTestMessages() (r string, exists bool) {
	v := m.e2e_failed_test_messages
	if v == nil {
		return
	}
	return *v, true
}

// OldE2eFailedTestMessages returns the old "e2e_failed_test_messages" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldE2eFailedTestMessages(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldE2eFailedTestMessages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldE2eFailedTestMessages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldE2eFailedTestMessages: %w", err)
	}
	return oldValue.E2eFailedTestMessages, nil
}

// ClearE2eFailedTestMessages clears the value of the "e2e_failed_test_messages" field.
func (m *ProwJobsMutation) ClearE2eFailedTestMessages() {
	m.e2e_failed_test_messages = nil
	m.clearedFields[prowjobs.FieldE2eFailedTestMessages] = struct{}{}
}

// E2eFailedTestMessagesCleared returns if the "e2e_failed_test_messages" field was cleared in this mutation.
func (m *ProwJobsMutation) E2eFailedTestMessagesCleared() bool {
	_, ok := m.clearedFields[prowjobs.FieldE2eFailedTestMessages]
	return ok
}

// ResetE2eFailedTestMessages resets all changes to the "e2e_failed_test_messages" field.
func (m *ProwJobsMutation) ResetE2eFailedTestMessages() {
	m.e2e_failed_test_messages = nil
	delete(m.clearedFields, prowjobs.FieldE2eFailedTestMessages)
}

// SetSuitesXMLURL sets the "suites_xml_url" field.
func (m *ProwJobsMutation) SetSuitesXMLURL(s string) {
	m.suites_xml_url = &s
}

// SuitesXMLURL returns the value of the "suites_xml_url" field in the mutation.
func (m *ProwJobsMutation) SuitesXMLURL() (r string, exists bool) {
	v := m.suites_xml_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSuitesXMLURL returns the old "suites_xml_url" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldSuitesXMLURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuitesXMLURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuitesXMLURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuitesXMLURL: %w", err)
	}
	return oldValue.SuitesXMLURL, nil
}

// ClearSuitesXMLURL clears the value of the "suites_xml_url" field.
func (m *ProwJobsMutation) ClearSuitesXMLURL() {
	m.suites_xml_url = nil
	m.clearedFields[prowjobs.FieldSuitesXMLURL] = struct{}{}
}

// SuitesXMLURLCleared returns if the "suites_xml_url" field was cleared in this mutation.
func (m *ProwJobsMutation) SuitesXMLURLCleared() bool {
	_, ok := m.clearedFields[prowjobs.FieldSuitesXMLURL]
	return ok
}

// ResetSuitesXMLURL resets all changes to the "suites_xml_url" field.
func (m *ProwJobsMutation) ResetSuitesXMLURL() {
	m.suites_xml_url = nil
	delete(m.clearedFields, prowjobs.FieldSuitesXMLURL)
}

// SetBuildErrorLogs sets the "build_error_logs" field.
func (m *ProwJobsMutation) SetBuildErrorLogs(s string) {
	m.build_error_logs = &s
}

// BuildErrorLogs returns the value of the "build_error_logs" field in the mutation.
func (m *ProwJobsMutation) BuildErrorLogs() (r string, exists bool) {
	v := m.build_error_logs
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildErrorLogs returns the old "build_error_logs" field's value of the ProwJobs entity.
// If the ProwJobs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwJobsMutation) OldBuildErrorLogs(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildErrorLogs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildErrorLogs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildErrorLogs: %w", err)
	}
	return oldValue.BuildErrorLogs, nil
}

// ClearBuildErrorLogs clears the value of the "build_error_logs" field.
func (m *ProwJobsMutation) ClearBuildErrorLogs() {
	m.build_error_logs = nil
	m.clearedFields[prowjobs.FieldBuildErrorLogs] = struct{}{}
}

// BuildErrorLogsCleared returns if the "build_error_logs" field was cleared in this mutation.
func (m *ProwJobsMutation) BuildErrorLogsCleared() bool {
	_, ok := m.clearedFields[prowjobs.FieldBuildErrorLogs]
	return ok
}

// ResetBuildErrorLogs resets all changes to the "build_error_logs" field.
func (m *ProwJobsMutation) ResetBuildErrorLogs() {
	m.build_error_logs = nil
	delete(m.clearedFields, prowjobs.FieldBuildErrorLogs)
}

// SetProwJobsID sets the "prow_jobs" edge to the Repository entity by id.
func (m *ProwJobsMutation) SetProwJobsID(id string) {
	m.prow_jobs = &id
}

// ClearProwJobs clears the "prow_jobs" edge to the Repository entity.
func (m *ProwJobsMutation) ClearProwJobs() {
	m.clearedprow_jobs = true
}

// ProwJobsCleared reports if the "prow_jobs" edge to the Repository entity was cleared.
func (m *ProwJobsMutation) ProwJobsCleared() bool {
	return m.clearedprow_jobs
}

// ProwJobsID returns the "prow_jobs" edge ID in the mutation.
func (m *ProwJobsMutation) ProwJobsID() (id string, exists bool) {
	if m.prow_jobs != nil {
		return *m.prow_jobs, true
	}
	return
}

// ProwJobsIDs returns the "prow_jobs" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProwJobsID instead. It exists only for internal usage by the builders.
func (m *ProwJobsMutation) ProwJobsIDs() (ids []string) {
	if id := m.prow_jobs; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProwJobs resets all changes to the "prow_jobs" edge.
func (m *ProwJobsMutation) ResetProwJobs() {
	m.prow_jobs = nil
	m.clearedprow_jobs = false
}

// Where appends a list predicates to the ProwJobsMutation builder.
func (m *ProwJobsMutation) Where(ps ...predicate.ProwJobs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProwJobsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProwJobsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProwJobs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProwJobsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProwJobsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProwJobs).
func (m *ProwJobsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProwJobsMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.job_id != nil {
		fields = append(fields, prowjobs.FieldJobID)
	}
	if m.created_at != nil {
		fields = append(fields, prowjobs.FieldCreatedAt)
	}
	if m.duration != nil {
		fields = append(fields, prowjobs.FieldDuration)
	}
	if m.tests_count != nil {
		fields = append(fields, prowjobs.FieldTestsCount)
	}
	if m.failed_count != nil {
		fields = append(fields, prowjobs.FieldFailedCount)
	}
	if m.skipped_count != nil {
		fields = append(fields, prowjobs.FieldSkippedCount)
	}
	if m.job_name != nil {
		fields = append(fields, prowjobs.FieldJobName)
	}
	if m.job_type != nil {
		fields = append(fields, prowjobs.FieldJobType)
	}
	if m.state != nil {
		fields = append(fields, prowjobs.FieldState)
	}
	if m.job_url != nil {
		fields = append(fields, prowjobs.FieldJobURL)
	}
	if m.ci_failed != nil {
		fields = append(fields, prowjobs.FieldCiFailed)
	}
	if m.external_services_impact != nil {
		fields = append(fields, prowjobs.FieldExternalServicesImpact)
	}
	if m.e2e_failed_test_messages != nil {
		fields = append(fields, prowjobs.FieldE2eFailedTestMessages)
	}
	if m.suites_xml_url != nil {
		fields = append(fields, prowjobs.FieldSuitesXMLURL)
	}
	if m.build_error_logs != nil {
		fields = append(fields, prowjobs.FieldBuildErrorLogs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProwJobsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prowjobs.FieldJobID:
		return m.JobID()
	case prowjobs.FieldCreatedAt:
		return m.CreatedAt()
	case prowjobs.FieldDuration:
		return m.Duration()
	case prowjobs.FieldTestsCount:
		return m.TestsCount()
	case prowjobs.FieldFailedCount:
		return m.FailedCount()
	case prowjobs.FieldSkippedCount:
		return m.SkippedCount()
	case prowjobs.FieldJobName:
		return m.JobName()
	case prowjobs.FieldJobType:
		return m.JobType()
	case prowjobs.FieldState:
		return m.State()
	case prowjobs.FieldJobURL:
		return m.JobURL()
	case prowjobs.FieldCiFailed:
		return m.CiFailed()
	case prowjobs.FieldExternalServicesImpact:
		return m.ExternalServicesImpact()
	case prowjobs.FieldE2eFailedTestMessages:
		return m.E2eFailedTestMessages()
	case prowjobs.FieldSuitesXMLURL:
		return m.SuitesXMLURL()
	case prowjobs.FieldBuildErrorLogs:
		return m.BuildErrorLogs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProwJobsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prowjobs.FieldJobID:
		return m.OldJobID(ctx)
	case prowjobs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case prowjobs.FieldDuration:
		return m.OldDuration(ctx)
	case prowjobs.FieldTestsCount:
		return m.OldTestsCount(ctx)
	case prowjobs.FieldFailedCount:
		return m.OldFailedCount(ctx)
	case prowjobs.FieldSkippedCount:
		return m.OldSkippedCount(ctx)
	case prowjobs.FieldJobName:
		return m.OldJobName(ctx)
	case prowjobs.FieldJobType:
		return m.OldJobType(ctx)
	case prowjobs.FieldState:
		return m.OldState(ctx)
	case prowjobs.FieldJobURL:
		return m.OldJobURL(ctx)
	case prowjobs.FieldCiFailed:
		return m.OldCiFailed(ctx)
	case prowjobs.FieldExternalServicesImpact:
		return m.OldExternalServicesImpact(ctx)
	case prowjobs.FieldE2eFailedTestMessages:
		return m.OldE2eFailedTestMessages(ctx)
	case prowjobs.FieldSuitesXMLURL:
		return m.OldSuitesXMLURL(ctx)
	case prowjobs.FieldBuildErrorLogs:
		return m.OldBuildErrorLogs(ctx)
	}
	return nil, fmt.Errorf("unknown ProwJobs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProwJobsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prowjobs.FieldJobID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobID(v)
		return nil
	case prowjobs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case prowjobs.FieldDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case prowjobs.FieldTestsCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestsCount(v)
		return nil
	case prowjobs.FieldFailedCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailedCount(v)
		return nil
	case prowjobs.FieldSkippedCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkippedCount(v)
		return nil
	case prowjobs.FieldJobName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobName(v)
		return nil
	case prowjobs.FieldJobType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobType(v)
		return nil
	case prowjobs.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case prowjobs.FieldJobURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobURL(v)
		return nil
	case prowjobs.FieldCiFailed:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCiFailed(v)
		return nil
	case prowjobs.FieldExternalServicesImpact:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalServicesImpact(v)
		return nil
	case prowjobs.FieldE2eFailedTestMessages:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetE2eFailedTestMessages(v)
		return nil
	case prowjobs.FieldSuitesXMLURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuitesXMLURL(v)
		return nil
	case prowjobs.FieldBuildErrorLogs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildErrorLogs(v)
		return nil
	}
	return fmt.Errorf("unknown ProwJobs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProwJobsMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, prowjobs.FieldDuration)
	}
	if m.addtests_count != nil {
		fields = append(fields, prowjobs.FieldTestsCount)
	}
	if m.addfailed_count != nil {
		fields = append(fields, prowjobs.FieldFailedCount)
	}
	if m.addskipped_count != nil {
		fields = append(fields, prowjobs.FieldSkippedCount)
	}
	if m.addci_failed != nil {
		fields = append(fields, prowjobs.FieldCiFailed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProwJobsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case prowjobs.FieldDuration:
		return m.AddedDuration()
	case prowjobs.FieldTestsCount:
		return m.AddedTestsCount()
	case prowjobs.FieldFailedCount:
		return m.AddedFailedCount()
	case prowjobs.FieldSkippedCount:
		return m.AddedSkippedCount()
	case prowjobs.FieldCiFailed:
		return m.AddedCiFailed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProwJobsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case prowjobs.FieldDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case prowjobs.FieldTestsCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTestsCount(v)
		return nil
	case prowjobs.FieldFailedCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFailedCount(v)
		return nil
	case prowjobs.FieldSkippedCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSkippedCount(v)
		return nil
	case prowjobs.FieldCiFailed:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCiFailed(v)
		return nil
	}
	return fmt.Errorf("unknown ProwJobs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProwJobsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(prowjobs.FieldTestsCount) {
		fields = append(fields, prowjobs.FieldTestsCount)
	}
	if m.FieldCleared(prowjobs.FieldFailedCount) {
		fields = append(fields, prowjobs.FieldFailedCount)
	}
	if m.FieldCleared(prowjobs.FieldSkippedCount) {
		fields = append(fields, prowjobs.FieldSkippedCount)
	}
	if m.FieldCleared(prowjobs.FieldExternalServicesImpact) {
		fields = append(fields, prowjobs.FieldExternalServicesImpact)
	}
	if m.FieldCleared(prowjobs.FieldE2eFailedTestMessages) {
		fields = append(fields, prowjobs.FieldE2eFailedTestMessages)
	}
	if m.FieldCleared(prowjobs.FieldSuitesXMLURL) {
		fields = append(fields, prowjobs.FieldSuitesXMLURL)
	}
	if m.FieldCleared(prowjobs.FieldBuildErrorLogs) {
		fields = append(fields, prowjobs.FieldBuildErrorLogs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProwJobsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProwJobsMutation) ClearField(name string) error {
	switch name {
	case prowjobs.FieldTestsCount:
		m.ClearTestsCount()
		return nil
	case prowjobs.FieldFailedCount:
		m.ClearFailedCount()
		return nil
	case prowjobs.FieldSkippedCount:
		m.ClearSkippedCount()
		return nil
	case prowjobs.FieldExternalServicesImpact:
		m.ClearExternalServicesImpact()
		return nil
	case prowjobs.FieldE2eFailedTestMessages:
		m.ClearE2eFailedTestMessages()
		return nil
	case prowjobs.FieldSuitesXMLURL:
		m.ClearSuitesXMLURL()
		return nil
	case prowjobs.FieldBuildErrorLogs:
		m.ClearBuildErrorLogs()
		return nil
	}
	return fmt.Errorf("unknown ProwJobs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProwJobsMutation) ResetField(name string) error {
	switch name {
	case prowjobs.FieldJobID:
		m.ResetJobID()
		return nil
	case prowjobs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case prowjobs.FieldDuration:
		m.ResetDuration()
		return nil
	case prowjobs.FieldTestsCount:
		m.ResetTestsCount()
		return nil
	case prowjobs.FieldFailedCount:
		m.ResetFailedCount()
		return nil
	case prowjobs.FieldSkippedCount:
		m.ResetSkippedCount()
		return nil
	case prowjobs.FieldJobName:
		m.ResetJobName()
		return nil
	case prowjobs.FieldJobType:
		m.ResetJobType()
		return nil
	case prowjobs.FieldState:
		m.ResetState()
		return nil
	case prowjobs.FieldJobURL:
		m.ResetJobURL()
		return nil
	case prowjobs.FieldCiFailed:
		m.ResetCiFailed()
		return nil
	case prowjobs.FieldExternalServicesImpact:
		m.ResetExternalServicesImpact()
		return nil
	case prowjobs.FieldE2eFailedTestMessages:
		m.ResetE2eFailedTestMessages()
		return nil
	case prowjobs.FieldSuitesXMLURL:
		m.ResetSuitesXMLURL()
		return nil
	case prowjobs.FieldBuildErrorLogs:
		m.ResetBuildErrorLogs()
		return nil
	}
	return fmt.Errorf("unknown ProwJobs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProwJobsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.prow_jobs != nil {
		edges = append(edges, prowjobs.EdgeProwJobs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProwJobsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prowjobs.EdgeProwJobs:
		if id := m.prow_jobs; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProwJobsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProwJobsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProwJobsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprow_jobs {
		edges = append(edges, prowjobs.EdgeProwJobs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProwJobsMutation) EdgeCleared(name string) bool {
	switch name {
	case prowjobs.EdgeProwJobs:
		return m.clearedprow_jobs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProwJobsMutation) ClearEdge(name string) error {
	switch name {
	case prowjobs.EdgeProwJobs:
		m.ClearProwJobs()
		return nil
	}
	return fmt.Errorf("unknown ProwJobs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProwJobsMutation) ResetEdge(name string) error {
	switch name {
	case prowjobs.EdgeProwJobs:
		m.ResetProwJobs()
		return nil
	}
	return fmt.Errorf("unknown ProwJobs edge %s", name)
}

// ProwSuitesMutation represents an operation that mutates the ProwSuites nodes in the graph.
type ProwSuitesMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	job_id                   *string
	job_url                  *string
	job_name                 *string
	suite_name               *string
	name                     *string
	status                   *string
	error_message            *string
	external_services_impact *bool
	time                     *float64
	addtime                  *float64
	created_at               *time.Time
	clearedFields            map[string]struct{}
	prow_suites              *string
	clearedprow_suites       bool
	done                     bool
	oldValue                 func(context.Context) (*ProwSuites, error)
	predicates               []predicate.ProwSuites
}

var _ ent.Mutation = (*ProwSuitesMutation)(nil)

// prowsuitesOption allows management of the mutation configuration using functional options.
type prowsuitesOption func(*ProwSuitesMutation)

// newProwSuitesMutation creates new mutation for the ProwSuites entity.
func newProwSuitesMutation(c config, op Op, opts ...prowsuitesOption) *ProwSuitesMutation {
	m := &ProwSuitesMutation{
		config:        c,
		op:            op,
		typ:           TypeProwSuites,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProwSuitesID sets the ID field of the mutation.
func withProwSuitesID(id int) prowsuitesOption {
	return func(m *ProwSuitesMutation) {
		var (
			err   error
			once  sync.Once
			value *ProwSuites
		)
		m.oldValue = func(ctx context.Context) (*ProwSuites, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProwSuites.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProwSuites sets the old ProwSuites of the mutation.
func withProwSuites(node *ProwSuites) prowsuitesOption {
	return func(m *ProwSuitesMutation) {
		m.oldValue = func(context.Context) (*ProwSuites, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProwSuitesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProwSuitesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProwSuitesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProwSuitesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProwSuites.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJobID sets the "job_id" field.
func (m *ProwSuitesMutation) SetJobID(s string) {
	m.job_id = &s
}

// JobID returns the value of the "job_id" field in the mutation.
func (m *ProwSuitesMutation) JobID() (r string, exists bool) {
	v := m.job_id
	if v == nil {
		return
	}
	return *v, true
}

// OldJobID returns the old "job_id" field's value of the ProwSuites entity.
// If the ProwSuites object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwSuitesMutation) OldJobID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobID: %w", err)
	}
	return oldValue.JobID, nil
}

// ResetJobID resets all changes to the "job_id" field.
func (m *ProwSuitesMutation) ResetJobID() {
	m.job_id = nil
}

// SetJobURL sets the "job_url" field.
func (m *ProwSuitesMutation) SetJobURL(s string) {
	m.job_url = &s
}

// JobURL returns the value of the "job_url" field in the mutation.
func (m *ProwSuitesMutation) JobURL() (r string, exists bool) {
	v := m.job_url
	if v == nil {
		return
	}
	return *v, true
}

// OldJobURL returns the old "job_url" field's value of the ProwSuites entity.
// If the ProwSuites object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwSuitesMutation) OldJobURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobURL: %w", err)
	}
	return oldValue.JobURL, nil
}

// ResetJobURL resets all changes to the "job_url" field.
func (m *ProwSuitesMutation) ResetJobURL() {
	m.job_url = nil
}

// SetJobName sets the "job_name" field.
func (m *ProwSuitesMutation) SetJobName(s string) {
	m.job_name = &s
}

// JobName returns the value of the "job_name" field in the mutation.
func (m *ProwSuitesMutation) JobName() (r string, exists bool) {
	v := m.job_name
	if v == nil {
		return
	}
	return *v, true
}

// OldJobName returns the old "job_name" field's value of the ProwSuites entity.
// If the ProwSuites object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwSuitesMutation) OldJobName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobName: %w", err)
	}
	return oldValue.JobName, nil
}

// ResetJobName resets all changes to the "job_name" field.
func (m *ProwSuitesMutation) ResetJobName() {
	m.job_name = nil
}

// SetSuiteName sets the "suite_name" field.
func (m *ProwSuitesMutation) SetSuiteName(s string) {
	m.suite_name = &s
}

// SuiteName returns the value of the "suite_name" field in the mutation.
func (m *ProwSuitesMutation) SuiteName() (r string, exists bool) {
	v := m.suite_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSuiteName returns the old "suite_name" field's value of the ProwSuites entity.
// If the ProwSuites object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwSuitesMutation) OldSuiteName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuiteName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuiteName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuiteName: %w", err)
	}
	return oldValue.SuiteName, nil
}

// ResetSuiteName resets all changes to the "suite_name" field.
func (m *ProwSuitesMutation) ResetSuiteName() {
	m.suite_name = nil
}

// SetName sets the "name" field.
func (m *ProwSuitesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProwSuitesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProwSuites entity.
// If the ProwSuites object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwSuitesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProwSuitesMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *ProwSuitesMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ProwSuitesMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProwSuites entity.
// If the ProwSuites object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwSuitesMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProwSuitesMutation) ResetStatus() {
	m.status = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *ProwSuitesMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *ProwSuitesMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the ProwSuites entity.
// If the ProwSuites object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwSuitesMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *ProwSuitesMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[prowsuites.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *ProwSuitesMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[prowsuites.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *ProwSuitesMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, prowsuites.FieldErrorMessage)
}

// SetExternalServicesImpact sets the "external_services_impact" field.
func (m *ProwSuitesMutation) SetExternalServicesImpact(b bool) {
	m.external_services_impact = &b
}

// ExternalServicesImpact returns the value of the "external_services_impact" field in the mutation.
func (m *ProwSuitesMutation) ExternalServicesImpact() (r bool, exists bool) {
	v := m.external_services_impact
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalServicesImpact returns the old "external_services_impact" field's value of the ProwSuites entity.
// If the ProwSuites object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwSuitesMutation) OldExternalServicesImpact(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalServicesImpact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalServicesImpact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalServicesImpact: %w", err)
	}
	return oldValue.ExternalServicesImpact, nil
}

// ClearExternalServicesImpact clears the value of the "external_services_impact" field.
func (m *ProwSuitesMutation) ClearExternalServicesImpact() {
	m.external_services_impact = nil
	m.clearedFields[prowsuites.FieldExternalServicesImpact] = struct{}{}
}

// ExternalServicesImpactCleared returns if the "external_services_impact" field was cleared in this mutation.
func (m *ProwSuitesMutation) ExternalServicesImpactCleared() bool {
	_, ok := m.clearedFields[prowsuites.FieldExternalServicesImpact]
	return ok
}

// ResetExternalServicesImpact resets all changes to the "external_services_impact" field.
func (m *ProwSuitesMutation) ResetExternalServicesImpact() {
	m.external_services_impact = nil
	delete(m.clearedFields, prowsuites.FieldExternalServicesImpact)
}

// SetTime sets the "time" field.
func (m *ProwSuitesMutation) SetTime(f float64) {
	m.time = &f
	m.addtime = nil
}

// Time returns the value of the "time" field in the mutation.
func (m *ProwSuitesMutation) Time() (r float64, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the ProwSuites entity.
// If the ProwSuites object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwSuitesMutation) OldTime(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// AddTime adds f to the "time" field.
func (m *ProwSuitesMutation) AddTime(f float64) {
	if m.addtime != nil {
		*m.addtime += f
	} else {
		m.addtime = &f
	}
}

// AddedTime returns the value that was added to the "time" field in this mutation.
func (m *ProwSuitesMutation) AddedTime() (r float64, exists bool) {
	v := m.addtime
	if v == nil {
		return
	}
	return *v, true
}

// ResetTime resets all changes to the "time" field.
func (m *ProwSuitesMutation) ResetTime() {
	m.time = nil
	m.addtime = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProwSuitesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProwSuitesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProwSuites entity.
// If the ProwSuites object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProwSuitesMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProwSuitesMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[prowsuites.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProwSuitesMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[prowsuites.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProwSuitesMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, prowsuites.FieldCreatedAt)
}

// SetProwSuitesID sets the "prow_suites" edge to the Repository entity by id.
func (m *ProwSuitesMutation) SetProwSuitesID(id string) {
	m.prow_suites = &id
}

// ClearProwSuites clears the "prow_suites" edge to the Repository entity.
func (m *ProwSuitesMutation) ClearProwSuites() {
	m.clearedprow_suites = true
}

// ProwSuitesCleared reports if the "prow_suites" edge to the Repository entity was cleared.
func (m *ProwSuitesMutation) ProwSuitesCleared() bool {
	return m.clearedprow_suites
}

// ProwSuitesID returns the "prow_suites" edge ID in the mutation.
func (m *ProwSuitesMutation) ProwSuitesID() (id string, exists bool) {
	if m.prow_suites != nil {
		return *m.prow_suites, true
	}
	return
}

// ProwSuitesIDs returns the "prow_suites" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProwSuitesID instead. It exists only for internal usage by the builders.
func (m *ProwSuitesMutation) ProwSuitesIDs() (ids []string) {
	if id := m.prow_suites; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProwSuites resets all changes to the "prow_suites" edge.
func (m *ProwSuitesMutation) ResetProwSuites() {
	m.prow_suites = nil
	m.clearedprow_suites = false
}

// Where appends a list predicates to the ProwSuitesMutation builder.
func (m *ProwSuitesMutation) Where(ps ...predicate.ProwSuites) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProwSuitesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProwSuitesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProwSuites, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProwSuitesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProwSuitesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProwSuites).
func (m *ProwSuitesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProwSuitesMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.job_id != nil {
		fields = append(fields, prowsuites.FieldJobID)
	}
	if m.job_url != nil {
		fields = append(fields, prowsuites.FieldJobURL)
	}
	if m.job_name != nil {
		fields = append(fields, prowsuites.FieldJobName)
	}
	if m.suite_name != nil {
		fields = append(fields, prowsuites.FieldSuiteName)
	}
	if m.name != nil {
		fields = append(fields, prowsuites.FieldName)
	}
	if m.status != nil {
		fields = append(fields, prowsuites.FieldStatus)
	}
	if m.error_message != nil {
		fields = append(fields, prowsuites.FieldErrorMessage)
	}
	if m.external_services_impact != nil {
		fields = append(fields, prowsuites.FieldExternalServicesImpact)
	}
	if m.time != nil {
		fields = append(fields, prowsuites.FieldTime)
	}
	if m.created_at != nil {
		fields = append(fields, prowsuites.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProwSuitesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prowsuites.FieldJobID:
		return m.JobID()
	case prowsuites.FieldJobURL:
		return m.JobURL()
	case prowsuites.FieldJobName:
		return m.JobName()
	case prowsuites.FieldSuiteName:
		return m.SuiteName()
	case prowsuites.FieldName:
		return m.Name()
	case prowsuites.FieldStatus:
		return m.Status()
	case prowsuites.FieldErrorMessage:
		return m.ErrorMessage()
	case prowsuites.FieldExternalServicesImpact:
		return m.ExternalServicesImpact()
	case prowsuites.FieldTime:
		return m.Time()
	case prowsuites.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProwSuitesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prowsuites.FieldJobID:
		return m.OldJobID(ctx)
	case prowsuites.FieldJobURL:
		return m.OldJobURL(ctx)
	case prowsuites.FieldJobName:
		return m.OldJobName(ctx)
	case prowsuites.FieldSuiteName:
		return m.OldSuiteName(ctx)
	case prowsuites.FieldName:
		return m.OldName(ctx)
	case prowsuites.FieldStatus:
		return m.OldStatus(ctx)
	case prowsuites.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case prowsuites.FieldExternalServicesImpact:
		return m.OldExternalServicesImpact(ctx)
	case prowsuites.FieldTime:
		return m.OldTime(ctx)
	case prowsuites.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProwSuites field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProwSuitesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prowsuites.FieldJobID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobID(v)
		return nil
	case prowsuites.FieldJobURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobURL(v)
		return nil
	case prowsuites.FieldJobName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobName(v)
		return nil
	case prowsuites.FieldSuiteName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuiteName(v)
		return nil
	case prowsuites.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case prowsuites.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case prowsuites.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case prowsuites.FieldExternalServicesImpact:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalServicesImpact(v)
		return nil
	case prowsuites.FieldTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case prowsuites.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProwSuites field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProwSuitesMutation) AddedFields() []string {
	var fields []string
	if m.addtime != nil {
		fields = append(fields, prowsuites.FieldTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProwSuitesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case prowsuites.FieldTime:
		return m.AddedTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProwSuitesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case prowsuites.FieldTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTime(v)
		return nil
	}
	return fmt.Errorf("unknown ProwSuites numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProwSuitesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(prowsuites.FieldErrorMessage) {
		fields = append(fields, prowsuites.FieldErrorMessage)
	}
	if m.FieldCleared(prowsuites.FieldExternalServicesImpact) {
		fields = append(fields, prowsuites.FieldExternalServicesImpact)
	}
	if m.FieldCleared(prowsuites.FieldCreatedAt) {
		fields = append(fields, prowsuites.FieldCreatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProwSuitesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProwSuitesMutation) ClearField(name string) error {
	switch name {
	case prowsuites.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case prowsuites.FieldExternalServicesImpact:
		m.ClearExternalServicesImpact()
		return nil
	case prowsuites.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProwSuites nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProwSuitesMutation) ResetField(name string) error {
	switch name {
	case prowsuites.FieldJobID:
		m.ResetJobID()
		return nil
	case prowsuites.FieldJobURL:
		m.ResetJobURL()
		return nil
	case prowsuites.FieldJobName:
		m.ResetJobName()
		return nil
	case prowsuites.FieldSuiteName:
		m.ResetSuiteName()
		return nil
	case prowsuites.FieldName:
		m.ResetName()
		return nil
	case prowsuites.FieldStatus:
		m.ResetStatus()
		return nil
	case prowsuites.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case prowsuites.FieldExternalServicesImpact:
		m.ResetExternalServicesImpact()
		return nil
	case prowsuites.FieldTime:
		m.ResetTime()
		return nil
	case prowsuites.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProwSuites field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProwSuitesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.prow_suites != nil {
		edges = append(edges, prowsuites.EdgeProwSuites)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProwSuitesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prowsuites.EdgeProwSuites:
		if id := m.prow_suites; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProwSuitesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProwSuitesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProwSuitesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprow_suites {
		edges = append(edges, prowsuites.EdgeProwSuites)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProwSuitesMutation) EdgeCleared(name string) bool {
	switch name {
	case prowsuites.EdgeProwSuites:
		return m.clearedprow_suites
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProwSuitesMutation) ClearEdge(name string) error {
	switch name {
	case prowsuites.EdgeProwSuites:
		m.ClearProwSuites()
		return nil
	}
	return fmt.Errorf("unknown ProwSuites unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProwSuitesMutation) ResetEdge(name string) error {
	switch name {
	case prowsuites.EdgeProwSuites:
		m.ResetProwSuites()
		return nil
	}
	return fmt.Errorf("unknown ProwSuites edge %s", name)
}

// PullRequestsMutation represents an operation that mutates the PullRequests nodes in the graph.
type PullRequestsMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	pr_id                        *uuid.UUID
	repository_name              *string
	repository_organization      *string
	number                       *int
	addnumber                    *int
	created_at                   *time.Time
	closed_at                    *time.Time
	merged_at                    *time.Time
	state                        *string
	author                       *string
	title                        *string
	merge_commit                 *string
	retest_count                 *float64
	addretest_count              *float64
	retest_before_merge_count    *float64
	addretest_before_merge_count *float64
	clearedFields                map[string]struct{}
	prs                          *string
	clearedprs                   bool
	done                         bool
	oldValue                     func(context.Context) (*PullRequests, error)
	predicates                   []predicate.PullRequests
}

var _ ent.Mutation = (*PullRequestsMutation)(nil)

// pullrequestsOption allows management of the mutation configuration using functional options.
type pullrequestsOption func(*PullRequestsMutation)

// newPullRequestsMutation creates new mutation for the PullRequests entity.
func newPullRequestsMutation(c config, op Op, opts ...pullrequestsOption) *PullRequestsMutation {
	m := &PullRequestsMutation{
		config:        c,
		op:            op,
		typ:           TypePullRequests,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPullRequestsID sets the ID field of the mutation.
func withPullRequestsID(id int) pullrequestsOption {
	return func(m *PullRequestsMutation) {
		var (
			err   error
			once  sync.Once
			value *PullRequests
		)
		m.oldValue = func(ctx context.Context) (*PullRequests, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PullRequests.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPullRequests sets the old PullRequests of the mutation.
func withPullRequests(node *PullRequests) pullrequestsOption {
	return func(m *PullRequestsMutation) {
		m.oldValue = func(context.Context) (*PullRequests, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PullRequestsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PullRequestsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PullRequestsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PullRequestsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PullRequests.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPrID sets the "pr_id" field.
func (m *PullRequestsMutation) SetPrID(u uuid.UUID) {
	m.pr_id = &u
}

// PrID returns the value of the "pr_id" field in the mutation.
func (m *PullRequestsMutation) PrID() (r uuid.UUID, exists bool) {
	v := m.pr_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPrID returns the old "pr_id" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldPrID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrID: %w", err)
	}
	return oldValue.PrID, nil
}

// ResetPrID resets all changes to the "pr_id" field.
func (m *PullRequestsMutation) ResetPrID() {
	m.pr_id = nil
}

// SetRepositoryName sets the "repository_name" field.
func (m *PullRequestsMutation) SetRepositoryName(s string) {
	m.repository_name = &s
}

// RepositoryName returns the value of the "repository_name" field in the mutation.
func (m *PullRequestsMutation) RepositoryName() (r string, exists bool) {
	v := m.repository_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRepositoryName returns the old "repository_name" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldRepositoryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepositoryName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepositoryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepositoryName: %w", err)
	}
	return oldValue.RepositoryName, nil
}

// ResetRepositoryName resets all changes to the "repository_name" field.
func (m *PullRequestsMutation) ResetRepositoryName() {
	m.repository_name = nil
}

// SetRepositoryOrganization sets the "repository_organization" field.
func (m *PullRequestsMutation) SetRepositoryOrganization(s string) {
	m.repository_organization = &s
}

// RepositoryOrganization returns the value of the "repository_organization" field in the mutation.
func (m *PullRequestsMutation) RepositoryOrganization() (r string, exists bool) {
	v := m.repository_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldRepositoryOrganization returns the old "repository_organization" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldRepositoryOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepositoryOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepositoryOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepositoryOrganization: %w", err)
	}
	return oldValue.RepositoryOrganization, nil
}

// ResetRepositoryOrganization resets all changes to the "repository_organization" field.
func (m *PullRequestsMutation) ResetRepositoryOrganization() {
	m.repository_organization = nil
}

// SetNumber sets the "number" field.
func (m *PullRequestsMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *PullRequestsMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *PullRequestsMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *PullRequestsMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *PullRequestsMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PullRequestsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PullRequestsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PullRequestsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetClosedAt sets the "closed_at" field.
func (m *PullRequestsMutation) SetClosedAt(t time.Time) {
	m.closed_at = &t
}

// ClosedAt returns the value of the "closed_at" field in the mutation.
func (m *PullRequestsMutation) ClosedAt() (r time.Time, exists bool) {
	v := m.closed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClosedAt returns the old "closed_at" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldClosedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClosedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClosedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosedAt: %w", err)
	}
	return oldValue.ClosedAt, nil
}

// ResetClosedAt resets all changes to the "closed_at" field.
func (m *PullRequestsMutation) ResetClosedAt() {
	m.closed_at = nil
}

// SetMergedAt sets the "merged_at" field.
func (m *PullRequestsMutation) SetMergedAt(t time.Time) {
	m.merged_at = &t
}

// MergedAt returns the value of the "merged_at" field in the mutation.
func (m *PullRequestsMutation) MergedAt() (r time.Time, exists bool) {
	v := m.merged_at
	if v == nil {
		return
	}
	return *v, true
}

// OldMergedAt returns the old "merged_at" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldMergedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMergedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMergedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMergedAt: %w", err)
	}
	return oldValue.MergedAt, nil
}

// ResetMergedAt resets all changes to the "merged_at" field.
func (m *PullRequestsMutation) ResetMergedAt() {
	m.merged_at = nil
}

// SetState sets the "state" field.
func (m *PullRequestsMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *PullRequestsMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *PullRequestsMutation) ResetState() {
	m.state = nil
}

// SetAuthor sets the "author" field.
func (m *PullRequestsMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *PullRequestsMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *PullRequestsMutation) ResetAuthor() {
	m.author = nil
}

// SetTitle sets the "title" field.
func (m *PullRequestsMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PullRequestsMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PullRequestsMutation) ResetTitle() {
	m.title = nil
}

// SetMergeCommit sets the "merge_commit" field.
func (m *PullRequestsMutation) SetMergeCommit(s string) {
	m.merge_commit = &s
}

// MergeCommit returns the value of the "merge_commit" field in the mutation.
func (m *PullRequestsMutation) MergeCommit() (r string, exists bool) {
	v := m.merge_commit
	if v == nil {
		return
	}
	return *v, true
}

// OldMergeCommit returns the old "merge_commit" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldMergeCommit(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMergeCommit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMergeCommit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMergeCommit: %w", err)
	}
	return oldValue.MergeCommit, nil
}

// ClearMergeCommit clears the value of the "merge_commit" field.
func (m *PullRequestsMutation) ClearMergeCommit() {
	m.merge_commit = nil
	m.clearedFields[pullrequests.FieldMergeCommit] = struct{}{}
}

// MergeCommitCleared returns if the "merge_commit" field was cleared in this mutation.
func (m *PullRequestsMutation) MergeCommitCleared() bool {
	_, ok := m.clearedFields[pullrequests.FieldMergeCommit]
	return ok
}

// ResetMergeCommit resets all changes to the "merge_commit" field.
func (m *PullRequestsMutation) ResetMergeCommit() {
	m.merge_commit = nil
	delete(m.clearedFields, pullrequests.FieldMergeCommit)
}

// SetRetestCount sets the "retest_count" field.
func (m *PullRequestsMutation) SetRetestCount(f float64) {
	m.retest_count = &f
	m.addretest_count = nil
}

// RetestCount returns the value of the "retest_count" field in the mutation.
func (m *PullRequestsMutation) RetestCount() (r float64, exists bool) {
	v := m.retest_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRetestCount returns the old "retest_count" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldRetestCount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetestCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetestCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetestCount: %w", err)
	}
	return oldValue.RetestCount, nil
}

// AddRetestCount adds f to the "retest_count" field.
func (m *PullRequestsMutation) AddRetestCount(f float64) {
	if m.addretest_count != nil {
		*m.addretest_count += f
	} else {
		m.addretest_count = &f
	}
}

// AddedRetestCount returns the value that was added to the "retest_count" field in this mutation.
func (m *PullRequestsMutation) AddedRetestCount() (r float64, exists bool) {
	v := m.addretest_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearRetestCount clears the value of the "retest_count" field.
func (m *PullRequestsMutation) ClearRetestCount() {
	m.retest_count = nil
	m.addretest_count = nil
	m.clearedFields[pullrequests.FieldRetestCount] = struct{}{}
}

// RetestCountCleared returns if the "retest_count" field was cleared in this mutation.
func (m *PullRequestsMutation) RetestCountCleared() bool {
	_, ok := m.clearedFields[pullrequests.FieldRetestCount]
	return ok
}

// ResetRetestCount resets all changes to the "retest_count" field.
func (m *PullRequestsMutation) ResetRetestCount() {
	m.retest_count = nil
	m.addretest_count = nil
	delete(m.clearedFields, pullrequests.FieldRetestCount)
}

// SetRetestBeforeMergeCount sets the "retest_before_merge_count" field.
func (m *PullRequestsMutation) SetRetestBeforeMergeCount(f float64) {
	m.retest_before_merge_count = &f
	m.addretest_before_merge_count = nil
}

// RetestBeforeMergeCount returns the value of the "retest_before_merge_count" field in the mutation.
func (m *PullRequestsMutation) RetestBeforeMergeCount() (r float64, exists bool) {
	v := m.retest_before_merge_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRetestBeforeMergeCount returns the old "retest_before_merge_count" field's value of the PullRequests entity.
// If the PullRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PullRequestsMutation) OldRetestBeforeMergeCount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetestBeforeMergeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetestBeforeMergeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetestBeforeMergeCount: %w", err)
	}
	return oldValue.RetestBeforeMergeCount, nil
}

// AddRetestBeforeMergeCount adds f to the "retest_before_merge_count" field.
func (m *PullRequestsMutation) AddRetestBeforeMergeCount(f float64) {
	if m.addretest_before_merge_count != nil {
		*m.addretest_before_merge_count += f
	} else {
		m.addretest_before_merge_count = &f
	}
}

// AddedRetestBeforeMergeCount returns the value that was added to the "retest_before_merge_count" field in this mutation.
func (m *PullRequestsMutation) AddedRetestBeforeMergeCount() (r float64, exists bool) {
	v := m.addretest_before_merge_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearRetestBeforeMergeCount clears the value of the "retest_before_merge_count" field.
func (m *PullRequestsMutation) ClearRetestBeforeMergeCount() {
	m.retest_before_merge_count = nil
	m.addretest_before_merge_count = nil
	m.clearedFields[pullrequests.FieldRetestBeforeMergeCount] = struct{}{}
}

// RetestBeforeMergeCountCleared returns if the "retest_before_merge_count" field was cleared in this mutation.
func (m *PullRequestsMutation) RetestBeforeMergeCountCleared() bool {
	_, ok := m.clearedFields[pullrequests.FieldRetestBeforeMergeCount]
	return ok
}

// ResetRetestBeforeMergeCount resets all changes to the "retest_before_merge_count" field.
func (m *PullRequestsMutation) ResetRetestBeforeMergeCount() {
	m.retest_before_merge_count = nil
	m.addretest_before_merge_count = nil
	delete(m.clearedFields, pullrequests.FieldRetestBeforeMergeCount)
}

// SetPrsID sets the "prs" edge to the Repository entity by id.
func (m *PullRequestsMutation) SetPrsID(id string) {
	m.prs = &id
}

// ClearPrs clears the "prs" edge to the Repository entity.
func (m *PullRequestsMutation) ClearPrs() {
	m.clearedprs = true
}

// PrsCleared reports if the "prs" edge to the Repository entity was cleared.
func (m *PullRequestsMutation) PrsCleared() bool {
	return m.clearedprs
}

// PrsID returns the "prs" edge ID in the mutation.
func (m *PullRequestsMutation) PrsID() (id string, exists bool) {
	if m.prs != nil {
		return *m.prs, true
	}
	return
}

// PrsIDs returns the "prs" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrsID instead. It exists only for internal usage by the builders.
func (m *PullRequestsMutation) PrsIDs() (ids []string) {
	if id := m.prs; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrs resets all changes to the "prs" edge.
func (m *PullRequestsMutation) ResetPrs() {
	m.prs = nil
	m.clearedprs = false
}

// Where appends a list predicates to the PullRequestsMutation builder.
func (m *PullRequestsMutation) Where(ps ...predicate.PullRequests) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PullRequestsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PullRequestsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PullRequests, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PullRequestsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PullRequestsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PullRequests).
func (m *PullRequestsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PullRequestsMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.pr_id != nil {
		fields = append(fields, pullrequests.FieldPrID)
	}
	if m.repository_name != nil {
		fields = append(fields, pullrequests.FieldRepositoryName)
	}
	if m.repository_organization != nil {
		fields = append(fields, pullrequests.FieldRepositoryOrganization)
	}
	if m.number != nil {
		fields = append(fields, pullrequests.FieldNumber)
	}
	if m.created_at != nil {
		fields = append(fields, pullrequests.FieldCreatedAt)
	}
	if m.closed_at != nil {
		fields = append(fields, pullrequests.FieldClosedAt)
	}
	if m.merged_at != nil {
		fields = append(fields, pullrequests.FieldMergedAt)
	}
	if m.state != nil {
		fields = append(fields, pullrequests.FieldState)
	}
	if m.author != nil {
		fields = append(fields, pullrequests.FieldAuthor)
	}
	if m.title != nil {
		fields = append(fields, pullrequests.FieldTitle)
	}
	if m.merge_commit != nil {
		fields = append(fields, pullrequests.FieldMergeCommit)
	}
	if m.retest_count != nil {
		fields = append(fields, pullrequests.FieldRetestCount)
	}
	if m.retest_before_merge_count != nil {
		fields = append(fields, pullrequests.FieldRetestBeforeMergeCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PullRequestsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pullrequests.FieldPrID:
		return m.PrID()
	case pullrequests.FieldRepositoryName:
		return m.RepositoryName()
	case pullrequests.FieldRepositoryOrganization:
		return m.RepositoryOrganization()
	case pullrequests.FieldNumber:
		return m.Number()
	case pullrequests.FieldCreatedAt:
		return m.CreatedAt()
	case pullrequests.FieldClosedAt:
		return m.ClosedAt()
	case pullrequests.FieldMergedAt:
		return m.MergedAt()
	case pullrequests.FieldState:
		return m.State()
	case pullrequests.FieldAuthor:
		return m.Author()
	case pullrequests.FieldTitle:
		return m.Title()
	case pullrequests.FieldMergeCommit:
		return m.MergeCommit()
	case pullrequests.FieldRetestCount:
		return m.RetestCount()
	case pullrequests.FieldRetestBeforeMergeCount:
		return m.RetestBeforeMergeCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PullRequestsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pullrequests.FieldPrID:
		return m.OldPrID(ctx)
	case pullrequests.FieldRepositoryName:
		return m.OldRepositoryName(ctx)
	case pullrequests.FieldRepositoryOrganization:
		return m.OldRepositoryOrganization(ctx)
	case pullrequests.FieldNumber:
		return m.OldNumber(ctx)
	case pullrequests.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pullrequests.FieldClosedAt:
		return m.OldClosedAt(ctx)
	case pullrequests.FieldMergedAt:
		return m.OldMergedAt(ctx)
	case pullrequests.FieldState:
		return m.OldState(ctx)
	case pullrequests.FieldAuthor:
		return m.OldAuthor(ctx)
	case pullrequests.FieldTitle:
		return m.OldTitle(ctx)
	case pullrequests.FieldMergeCommit:
		return m.OldMergeCommit(ctx)
	case pullrequests.FieldRetestCount:
		return m.OldRetestCount(ctx)
	case pullrequests.FieldRetestBeforeMergeCount:
		return m.OldRetestBeforeMergeCount(ctx)
	}
	return nil, fmt.Errorf("unknown PullRequests field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PullRequestsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pullrequests.FieldPrID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrID(v)
		return nil
	case pullrequests.FieldRepositoryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepositoryName(v)
		return nil
	case pullrequests.FieldRepositoryOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepositoryOrganization(v)
		return nil
	case pullrequests.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case pullrequests.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pullrequests.FieldClosedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosedAt(v)
		return nil
	case pullrequests.FieldMergedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMergedAt(v)
		return nil
	case pullrequests.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case pullrequests.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case pullrequests.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case pullrequests.FieldMergeCommit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMergeCommit(v)
		return nil
	case pullrequests.FieldRetestCount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetestCount(v)
		return nil
	case pullrequests.FieldRetestBeforeMergeCount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetestBeforeMergeCount(v)
		return nil
	}
	return fmt.Errorf("unknown PullRequests field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PullRequestsMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, pullrequests.FieldNumber)
	}
	if m.addretest_count != nil {
		fields = append(fields, pullrequests.FieldRetestCount)
	}
	if m.addretest_before_merge_count != nil {
		fields = append(fields, pullrequests.FieldRetestBeforeMergeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PullRequestsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pullrequests.FieldNumber:
		return m.AddedNumber()
	case pullrequests.FieldRetestCount:
		return m.AddedRetestCount()
	case pullrequests.FieldRetestBeforeMergeCount:
		return m.AddedRetestBeforeMergeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PullRequestsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pullrequests.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	case pullrequests.FieldRetestCount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetestCount(v)
		return nil
	case pullrequests.FieldRetestBeforeMergeCount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetestBeforeMergeCount(v)
		return nil
	}
	return fmt.Errorf("unknown PullRequests numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PullRequestsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pullrequests.FieldMergeCommit) {
		fields = append(fields, pullrequests.FieldMergeCommit)
	}
	if m.FieldCleared(pullrequests.FieldRetestCount) {
		fields = append(fields, pullrequests.FieldRetestCount)
	}
	if m.FieldCleared(pullrequests.FieldRetestBeforeMergeCount) {
		fields = append(fields, pullrequests.FieldRetestBeforeMergeCount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PullRequestsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PullRequestsMutation) ClearField(name string) error {
	switch name {
	case pullrequests.FieldMergeCommit:
		m.ClearMergeCommit()
		return nil
	case pullrequests.FieldRetestCount:
		m.ClearRetestCount()
		return nil
	case pullrequests.FieldRetestBeforeMergeCount:
		m.ClearRetestBeforeMergeCount()
		return nil
	}
	return fmt.Errorf("unknown PullRequests nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PullRequestsMutation) ResetField(name string) error {
	switch name {
	case pullrequests.FieldPrID:
		m.ResetPrID()
		return nil
	case pullrequests.FieldRepositoryName:
		m.ResetRepositoryName()
		return nil
	case pullrequests.FieldRepositoryOrganization:
		m.ResetRepositoryOrganization()
		return nil
	case pullrequests.FieldNumber:
		m.ResetNumber()
		return nil
	case pullrequests.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pullrequests.FieldClosedAt:
		m.ResetClosedAt()
		return nil
	case pullrequests.FieldMergedAt:
		m.ResetMergedAt()
		return nil
	case pullrequests.FieldState:
		m.ResetState()
		return nil
	case pullrequests.FieldAuthor:
		m.ResetAuthor()
		return nil
	case pullrequests.FieldTitle:
		m.ResetTitle()
		return nil
	case pullrequests.FieldMergeCommit:
		m.ResetMergeCommit()
		return nil
	case pullrequests.FieldRetestCount:
		m.ResetRetestCount()
		return nil
	case pullrequests.FieldRetestBeforeMergeCount:
		m.ResetRetestBeforeMergeCount()
		return nil
	}
	return fmt.Errorf("unknown PullRequests field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PullRequestsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.prs != nil {
		edges = append(edges, pullrequests.EdgePrs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PullRequestsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pullrequests.EdgePrs:
		if id := m.prs; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PullRequestsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PullRequestsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PullRequestsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprs {
		edges = append(edges, pullrequests.EdgePrs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PullRequestsMutation) EdgeCleared(name string) bool {
	switch name {
	case pullrequests.EdgePrs:
		return m.clearedprs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PullRequestsMutation) ClearEdge(name string) error {
	switch name {
	case pullrequests.EdgePrs:
		m.ClearPrs()
		return nil
	}
	return fmt.Errorf("unknown PullRequests unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PullRequestsMutation) ResetEdge(name string) error {
	switch name {
	case pullrequests.EdgePrs:
		m.ResetPrs()
		return nil
	}
	return fmt.Errorf("unknown PullRequests edge %s", name)
}

// RepositoryMutation represents an operation that mutates the Repository nodes in the graph.
type RepositoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	repository_name     *string
	git_organization    *string
	description         *string
	git_url             *string
	clearedFields       map[string]struct{}
	repositories        *uuid.UUID
	clearedrepositories bool
	workflows           map[int]struct{}
	removedworkflows    map[int]struct{}
	clearedworkflows    bool
	codecov             map[uuid.UUID]struct{}
	removedcodecov      map[uuid.UUID]struct{}
	clearedcodecov      bool
	prow_suites         map[int]struct{}
	removedprow_suites  map[int]struct{}
	clearedprow_suites  bool
	prow_jobs           map[int]struct{}
	removedprow_jobs    map[int]struct{}
	clearedprow_jobs    bool
	prs                 map[int]struct{}
	removedprs          map[int]struct{}
	clearedprs          bool
	done                bool
	oldValue            func(context.Context) (*Repository, error)
	predicates          []predicate.Repository
}

var _ ent.Mutation = (*RepositoryMutation)(nil)

// repositoryOption allows management of the mutation configuration using functional options.
type repositoryOption func(*RepositoryMutation)

// newRepositoryMutation creates new mutation for the Repository entity.
func newRepositoryMutation(c config, op Op, opts ...repositoryOption) *RepositoryMutation {
	m := &RepositoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRepository,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepositoryID sets the ID field of the mutation.
func withRepositoryID(id string) repositoryOption {
	return func(m *RepositoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Repository
		)
		m.oldValue = func(ctx context.Context) (*Repository, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repository.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepository sets the old Repository of the mutation.
func withRepository(node *Repository) repositoryOption {
	return func(m *RepositoryMutation) {
		m.oldValue = func(context.Context) (*Repository, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepositoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepositoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Repository entities.
func (m *RepositoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RepositoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RepositoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Repository.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRepositoryName sets the "repository_name" field.
func (m *RepositoryMutation) SetRepositoryName(s string) {
	m.repository_name = &s
}

// RepositoryName returns the value of the "repository_name" field in the mutation.
func (m *RepositoryMutation) RepositoryName() (r string, exists bool) {
	v := m.repository_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRepositoryName returns the old "repository_name" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldRepositoryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepositoryName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepositoryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepositoryName: %w", err)
	}
	return oldValue.RepositoryName, nil
}

// ResetRepositoryName resets all changes to the "repository_name" field.
func (m *RepositoryMutation) ResetRepositoryName() {
	m.repository_name = nil
}

// SetGitOrganization sets the "git_organization" field.
func (m *RepositoryMutation) SetGitOrganization(s string) {
	m.git_organization = &s
}

// GitOrganization returns the value of the "git_organization" field in the mutation.
func (m *RepositoryMutation) GitOrganization() (r string, exists bool) {
	v := m.git_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldGitOrganization returns the old "git_organization" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldGitOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitOrganization: %w", err)
	}
	return oldValue.GitOrganization, nil
}

// ResetGitOrganization resets all changes to the "git_organization" field.
func (m *RepositoryMutation) ResetGitOrganization() {
	m.git_organization = nil
}

// SetDescription sets the "description" field.
func (m *RepositoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RepositoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RepositoryMutation) ResetDescription() {
	m.description = nil
}

// SetGitURL sets the "git_url" field.
func (m *RepositoryMutation) SetGitURL(s string) {
	m.git_url = &s
}

// GitURL returns the value of the "git_url" field in the mutation.
func (m *RepositoryMutation) GitURL() (r string, exists bool) {
	v := m.git_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGitURL returns the old "git_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldGitURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitURL: %w", err)
	}
	return oldValue.GitURL, nil
}

// ResetGitURL resets all changes to the "git_url" field.
func (m *RepositoryMutation) ResetGitURL() {
	m.git_url = nil
}

// SetRepositoriesID sets the "repositories" edge to the Teams entity by id.
func (m *RepositoryMutation) SetRepositoriesID(id uuid.UUID) {
	m.repositories = &id
}

// ClearRepositories clears the "repositories" edge to the Teams entity.
func (m *RepositoryMutation) ClearRepositories() {
	m.clearedrepositories = true
}

// RepositoriesCleared reports if the "repositories" edge to the Teams entity was cleared.
func (m *RepositoryMutation) RepositoriesCleared() bool {
	return m.clearedrepositories
}

// RepositoriesID returns the "repositories" edge ID in the mutation.
func (m *RepositoryMutation) RepositoriesID() (id uuid.UUID, exists bool) {
	if m.repositories != nil {
		return *m.repositories, true
	}
	return
}

// RepositoriesIDs returns the "repositories" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepositoriesID instead. It exists only for internal usage by the builders.
func (m *RepositoryMutation) RepositoriesIDs() (ids []uuid.UUID) {
	if id := m.repositories; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepositories resets all changes to the "repositories" edge.
func (m *RepositoryMutation) ResetRepositories() {
	m.repositories = nil
	m.clearedrepositories = false
}

// AddWorkflowIDs adds the "workflows" edge to the Workflows entity by ids.
func (m *RepositoryMutation) AddWorkflowIDs(ids ...int) {
	if m.workflows == nil {
		m.workflows = make(map[int]struct{})
	}
	for i := range ids {
		m.workflows[ids[i]] = struct{}{}
	}
}

// ClearWorkflows clears the "workflows" edge to the Workflows entity.
func (m *RepositoryMutation) ClearWorkflows() {
	m.clearedworkflows = true
}

// WorkflowsCleared reports if the "workflows" edge to the Workflows entity was cleared.
func (m *RepositoryMutation) WorkflowsCleared() bool {
	return m.clearedworkflows
}

// RemoveWorkflowIDs removes the "workflows" edge to the Workflows entity by IDs.
func (m *RepositoryMutation) RemoveWorkflowIDs(ids ...int) {
	if m.removedworkflows == nil {
		m.removedworkflows = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.workflows, ids[i])
		m.removedworkflows[ids[i]] = struct{}{}
	}
}

// RemovedWorkflows returns the removed IDs of the "workflows" edge to the Workflows entity.
func (m *RepositoryMutation) RemovedWorkflowsIDs() (ids []int) {
	for id := range m.removedworkflows {
		ids = append(ids, id)
	}
	return
}

// WorkflowsIDs returns the "workflows" edge IDs in the mutation.
func (m *RepositoryMutation) WorkflowsIDs() (ids []int) {
	for id := range m.workflows {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflows resets all changes to the "workflows" edge.
func (m *RepositoryMutation) ResetWorkflows() {
	m.workflows = nil
	m.clearedworkflows = false
	m.removedworkflows = nil
}

// AddCodecovIDs adds the "codecov" edge to the CodeCov entity by ids.
func (m *RepositoryMutation) AddCodecovIDs(ids ...uuid.UUID) {
	if m.codecov == nil {
		m.codecov = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.codecov[ids[i]] = struct{}{}
	}
}

// ClearCodecov clears the "codecov" edge to the CodeCov entity.
func (m *RepositoryMutation) ClearCodecov() {
	m.clearedcodecov = true
}

// CodecovCleared reports if the "codecov" edge to the CodeCov entity was cleared.
func (m *RepositoryMutation) CodecovCleared() bool {
	return m.clearedcodecov
}

// RemoveCodecovIDs removes the "codecov" edge to the CodeCov entity by IDs.
func (m *RepositoryMutation) RemoveCodecovIDs(ids ...uuid.UUID) {
	if m.removedcodecov == nil {
		m.removedcodecov = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.codecov, ids[i])
		m.removedcodecov[ids[i]] = struct{}{}
	}
}

// RemovedCodecov returns the removed IDs of the "codecov" edge to the CodeCov entity.
func (m *RepositoryMutation) RemovedCodecovIDs() (ids []uuid.UUID) {
	for id := range m.removedcodecov {
		ids = append(ids, id)
	}
	return
}

// CodecovIDs returns the "codecov" edge IDs in the mutation.
func (m *RepositoryMutation) CodecovIDs() (ids []uuid.UUID) {
	for id := range m.codecov {
		ids = append(ids, id)
	}
	return
}

// ResetCodecov resets all changes to the "codecov" edge.
func (m *RepositoryMutation) ResetCodecov() {
	m.codecov = nil
	m.clearedcodecov = false
	m.removedcodecov = nil
}

// AddProwSuiteIDs adds the "prow_suites" edge to the ProwSuites entity by ids.
func (m *RepositoryMutation) AddProwSuiteIDs(ids ...int) {
	if m.prow_suites == nil {
		m.prow_suites = make(map[int]struct{})
	}
	for i := range ids {
		m.prow_suites[ids[i]] = struct{}{}
	}
}

// ClearProwSuites clears the "prow_suites" edge to the ProwSuites entity.
func (m *RepositoryMutation) ClearProwSuites() {
	m.clearedprow_suites = true
}

// ProwSuitesCleared reports if the "prow_suites" edge to the ProwSuites entity was cleared.
func (m *RepositoryMutation) ProwSuitesCleared() bool {
	return m.clearedprow_suites
}

// RemoveProwSuiteIDs removes the "prow_suites" edge to the ProwSuites entity by IDs.
func (m *RepositoryMutation) RemoveProwSuiteIDs(ids ...int) {
	if m.removedprow_suites == nil {
		m.removedprow_suites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.prow_suites, ids[i])
		m.removedprow_suites[ids[i]] = struct{}{}
	}
}

// RemovedProwSuites returns the removed IDs of the "prow_suites" edge to the ProwSuites entity.
func (m *RepositoryMutation) RemovedProwSuitesIDs() (ids []int) {
	for id := range m.removedprow_suites {
		ids = append(ids, id)
	}
	return
}

// ProwSuitesIDs returns the "prow_suites" edge IDs in the mutation.
func (m *RepositoryMutation) ProwSuitesIDs() (ids []int) {
	for id := range m.prow_suites {
		ids = append(ids, id)
	}
	return
}

// ResetProwSuites resets all changes to the "prow_suites" edge.
func (m *RepositoryMutation) ResetProwSuites() {
	m.prow_suites = nil
	m.clearedprow_suites = false
	m.removedprow_suites = nil
}

// AddProwJobIDs adds the "prow_jobs" edge to the ProwJobs entity by ids.
func (m *RepositoryMutation) AddProwJobIDs(ids ...int) {
	if m.prow_jobs == nil {
		m.prow_jobs = make(map[int]struct{})
	}
	for i := range ids {
		m.prow_jobs[ids[i]] = struct{}{}
	}
}

// ClearProwJobs clears the "prow_jobs" edge to the ProwJobs entity.
func (m *RepositoryMutation) ClearProwJobs() {
	m.clearedprow_jobs = true
}

// ProwJobsCleared reports if the "prow_jobs" edge to the ProwJobs entity was cleared.
func (m *RepositoryMutation) ProwJobsCleared() bool {
	return m.clearedprow_jobs
}

// RemoveProwJobIDs removes the "prow_jobs" edge to the ProwJobs entity by IDs.
func (m *RepositoryMutation) RemoveProwJobIDs(ids ...int) {
	if m.removedprow_jobs == nil {
		m.removedprow_jobs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.prow_jobs, ids[i])
		m.removedprow_jobs[ids[i]] = struct{}{}
	}
}

// RemovedProwJobs returns the removed IDs of the "prow_jobs" edge to the ProwJobs entity.
func (m *RepositoryMutation) RemovedProwJobsIDs() (ids []int) {
	for id := range m.removedprow_jobs {
		ids = append(ids, id)
	}
	return
}

// ProwJobsIDs returns the "prow_jobs" edge IDs in the mutation.
func (m *RepositoryMutation) ProwJobsIDs() (ids []int) {
	for id := range m.prow_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetProwJobs resets all changes to the "prow_jobs" edge.
func (m *RepositoryMutation) ResetProwJobs() {
	m.prow_jobs = nil
	m.clearedprow_jobs = false
	m.removedprow_jobs = nil
}

// AddPrIDs adds the "prs" edge to the PullRequests entity by ids.
func (m *RepositoryMutation) AddPrIDs(ids ...int) {
	if m.prs == nil {
		m.prs = make(map[int]struct{})
	}
	for i := range ids {
		m.prs[ids[i]] = struct{}{}
	}
}

// ClearPrs clears the "prs" edge to the PullRequests entity.
func (m *RepositoryMutation) ClearPrs() {
	m.clearedprs = true
}

// PrsCleared reports if the "prs" edge to the PullRequests entity was cleared.
func (m *RepositoryMutation) PrsCleared() bool {
	return m.clearedprs
}

// RemovePrIDs removes the "prs" edge to the PullRequests entity by IDs.
func (m *RepositoryMutation) RemovePrIDs(ids ...int) {
	if m.removedprs == nil {
		m.removedprs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.prs, ids[i])
		m.removedprs[ids[i]] = struct{}{}
	}
}

// RemovedPrs returns the removed IDs of the "prs" edge to the PullRequests entity.
func (m *RepositoryMutation) RemovedPrsIDs() (ids []int) {
	for id := range m.removedprs {
		ids = append(ids, id)
	}
	return
}

// PrsIDs returns the "prs" edge IDs in the mutation.
func (m *RepositoryMutation) PrsIDs() (ids []int) {
	for id := range m.prs {
		ids = append(ids, id)
	}
	return
}

// ResetPrs resets all changes to the "prs" edge.
func (m *RepositoryMutation) ResetPrs() {
	m.prs = nil
	m.clearedprs = false
	m.removedprs = nil
}

// Where appends a list predicates to the RepositoryMutation builder.
func (m *RepositoryMutation) Where(ps ...predicate.Repository) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RepositoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RepositoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Repository, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RepositoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RepositoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Repository).
func (m *RepositoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RepositoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.repository_name != nil {
		fields = append(fields, repository.FieldRepositoryName)
	}
	if m.git_organization != nil {
		fields = append(fields, repository.FieldGitOrganization)
	}
	if m.description != nil {
		fields = append(fields, repository.FieldDescription)
	}
	if m.git_url != nil {
		fields = append(fields, repository.FieldGitURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RepositoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repository.FieldRepositoryName:
		return m.RepositoryName()
	case repository.FieldGitOrganization:
		return m.GitOrganization()
	case repository.FieldDescription:
		return m.Description()
	case repository.FieldGitURL:
		return m.GitURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RepositoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repository.FieldRepositoryName:
		return m.OldRepositoryName(ctx)
	case repository.FieldGitOrganization:
		return m.OldGitOrganization(ctx)
	case repository.FieldDescription:
		return m.OldDescription(ctx)
	case repository.FieldGitURL:
		return m.OldGitURL(ctx)
	}
	return nil, fmt.Errorf("unknown Repository field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repository.FieldRepositoryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepositoryName(v)
		return nil
	case repository.FieldGitOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitOrganization(v)
		return nil
	case repository.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case repository.FieldGitURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitURL(v)
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RepositoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RepositoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Repository numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RepositoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RepositoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepositoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Repository nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RepositoryMutation) ResetField(name string) error {
	switch name {
	case repository.FieldRepositoryName:
		m.ResetRepositoryName()
		return nil
	case repository.FieldGitOrganization:
		m.ResetGitOrganization()
		return nil
	case repository.FieldDescription:
		m.ResetDescription()
		return nil
	case repository.FieldGitURL:
		m.ResetGitURL()
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RepositoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.repositories != nil {
		edges = append(edges, repository.EdgeRepositories)
	}
	if m.workflows != nil {
		edges = append(edges, repository.EdgeWorkflows)
	}
	if m.codecov != nil {
		edges = append(edges, repository.EdgeCodecov)
	}
	if m.prow_suites != nil {
		edges = append(edges, repository.EdgeProwSuites)
	}
	if m.prow_jobs != nil {
		edges = append(edges, repository.EdgeProwJobs)
	}
	if m.prs != nil {
		edges = append(edges, repository.EdgePrs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RepositoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgeRepositories:
		if id := m.repositories; id != nil {
			return []ent.Value{*id}
		}
	case repository.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.workflows))
		for id := range m.workflows {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeCodecov:
		ids := make([]ent.Value, 0, len(m.codecov))
		for id := range m.codecov {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeProwSuites:
		ids := make([]ent.Value, 0, len(m.prow_suites))
		for id := range m.prow_suites {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeProwJobs:
		ids := make([]ent.Value, 0, len(m.prow_jobs))
		for id := range m.prow_jobs {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgePrs:
		ids := make([]ent.Value, 0, len(m.prs))
		for id := range m.prs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RepositoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedworkflows != nil {
		edges = append(edges, repository.EdgeWorkflows)
	}
	if m.removedcodecov != nil {
		edges = append(edges, repository.EdgeCodecov)
	}
	if m.removedprow_suites != nil {
		edges = append(edges, repository.EdgeProwSuites)
	}
	if m.removedprow_jobs != nil {
		edges = append(edges, repository.EdgeProwJobs)
	}
	if m.removedprs != nil {
		edges = append(edges, repository.EdgePrs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RepositoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.removedworkflows))
		for id := range m.removedworkflows {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeCodecov:
		ids := make([]ent.Value, 0, len(m.removedcodecov))
		for id := range m.removedcodecov {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeProwSuites:
		ids := make([]ent.Value, 0, len(m.removedprow_suites))
		for id := range m.removedprow_suites {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeProwJobs:
		ids := make([]ent.Value, 0, len(m.removedprow_jobs))
		for id := range m.removedprow_jobs {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgePrs:
		ids := make([]ent.Value, 0, len(m.removedprs))
		for id := range m.removedprs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RepositoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedrepositories {
		edges = append(edges, repository.EdgeRepositories)
	}
	if m.clearedworkflows {
		edges = append(edges, repository.EdgeWorkflows)
	}
	if m.clearedcodecov {
		edges = append(edges, repository.EdgeCodecov)
	}
	if m.clearedprow_suites {
		edges = append(edges, repository.EdgeProwSuites)
	}
	if m.clearedprow_jobs {
		edges = append(edges, repository.EdgeProwJobs)
	}
	if m.clearedprs {
		edges = append(edges, repository.EdgePrs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RepositoryMutation) EdgeCleared(name string) bool {
	switch name {
	case repository.EdgeRepositories:
		return m.clearedrepositories
	case repository.EdgeWorkflows:
		return m.clearedworkflows
	case repository.EdgeCodecov:
		return m.clearedcodecov
	case repository.EdgeProwSuites:
		return m.clearedprow_suites
	case repository.EdgeProwJobs:
		return m.clearedprow_jobs
	case repository.EdgePrs:
		return m.clearedprs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RepositoryMutation) ClearEdge(name string) error {
	switch name {
	case repository.EdgeRepositories:
		m.ClearRepositories()
		return nil
	}
	return fmt.Errorf("unknown Repository unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RepositoryMutation) ResetEdge(name string) error {
	switch name {
	case repository.EdgeRepositories:
		m.ResetRepositories()
		return nil
	case repository.EdgeWorkflows:
		m.ResetWorkflows()
		return nil
	case repository.EdgeCodecov:
		m.ResetCodecov()
		return nil
	case repository.EdgeProwSuites:
		m.ResetProwSuites()
		return nil
	case repository.EdgeProwJobs:
		m.ResetProwJobs()
		return nil
	case repository.EdgePrs:
		m.ResetPrs()
		return nil
	}
	return fmt.Errorf("unknown Repository edge %s", name)
}

// TeamsMutation represents an operation that mutates the Teams nodes in the graph.
type TeamsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	team_name           *string
	description         *string
	jira_keys           *string
	clearedFields       map[string]struct{}
	repositories        map[string]struct{}
	removedrepositories map[string]struct{}
	clearedrepositories bool
	bugs                map[uuid.UUID]struct{}
	removedbugs         map[uuid.UUID]struct{}
	clearedbugs         bool
	failures            map[uuid.UUID]struct{}
	removedfailures     map[uuid.UUID]struct{}
	clearedfailures     bool
	done                bool
	oldValue            func(context.Context) (*Teams, error)
	predicates          []predicate.Teams
}

var _ ent.Mutation = (*TeamsMutation)(nil)

// teamsOption allows management of the mutation configuration using functional options.
type teamsOption func(*TeamsMutation)

// newTeamsMutation creates new mutation for the Teams entity.
func newTeamsMutation(c config, op Op, opts ...teamsOption) *TeamsMutation {
	m := &TeamsMutation{
		config:        c,
		op:            op,
		typ:           TypeTeams,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamsID sets the ID field of the mutation.
func withTeamsID(id uuid.UUID) teamsOption {
	return func(m *TeamsMutation) {
		var (
			err   error
			once  sync.Once
			value *Teams
		)
		m.oldValue = func(ctx context.Context) (*Teams, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Teams.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeams sets the old Teams of the mutation.
func withTeams(node *Teams) teamsOption {
	return func(m *TeamsMutation) {
		m.oldValue = func(context.Context) (*Teams, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Teams entities.
func (m *TeamsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Teams.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTeamName sets the "team_name" field.
func (m *TeamsMutation) SetTeamName(s string) {
	m.team_name = &s
}

// TeamName returns the value of the "team_name" field in the mutation.
func (m *TeamsMutation) TeamName() (r string, exists bool) {
	v := m.team_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamName returns the old "team_name" field's value of the Teams entity.
// If the Teams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamsMutation) OldTeamName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamName: %w", err)
	}
	return oldValue.TeamName, nil
}

// ResetTeamName resets all changes to the "team_name" field.
func (m *TeamsMutation) ResetTeamName() {
	m.team_name = nil
}

// SetDescription sets the "description" field.
func (m *TeamsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TeamsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Teams entity.
// If the Teams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TeamsMutation) ResetDescription() {
	m.description = nil
}

// SetJiraKeys sets the "jira_keys" field.
func (m *TeamsMutation) SetJiraKeys(s string) {
	m.jira_keys = &s
}

// JiraKeys returns the value of the "jira_keys" field in the mutation.
func (m *TeamsMutation) JiraKeys() (r string, exists bool) {
	v := m.jira_keys
	if v == nil {
		return
	}
	return *v, true
}

// OldJiraKeys returns the old "jira_keys" field's value of the Teams entity.
// If the Teams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamsMutation) OldJiraKeys(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJiraKeys is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJiraKeys requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJiraKeys: %w", err)
	}
	return oldValue.JiraKeys, nil
}

// ResetJiraKeys resets all changes to the "jira_keys" field.
func (m *TeamsMutation) ResetJiraKeys() {
	m.jira_keys = nil
}

// AddRepositoryIDs adds the "repositories" edge to the Repository entity by ids.
func (m *TeamsMutation) AddRepositoryIDs(ids ...string) {
	if m.repositories == nil {
		m.repositories = make(map[string]struct{})
	}
	for i := range ids {
		m.repositories[ids[i]] = struct{}{}
	}
}

// ClearRepositories clears the "repositories" edge to the Repository entity.
func (m *TeamsMutation) ClearRepositories() {
	m.clearedrepositories = true
}

// RepositoriesCleared reports if the "repositories" edge to the Repository entity was cleared.
func (m *TeamsMutation) RepositoriesCleared() bool {
	return m.clearedrepositories
}

// RemoveRepositoryIDs removes the "repositories" edge to the Repository entity by IDs.
func (m *TeamsMutation) RemoveRepositoryIDs(ids ...string) {
	if m.removedrepositories == nil {
		m.removedrepositories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.repositories, ids[i])
		m.removedrepositories[ids[i]] = struct{}{}
	}
}

// RemovedRepositories returns the removed IDs of the "repositories" edge to the Repository entity.
func (m *TeamsMutation) RemovedRepositoriesIDs() (ids []string) {
	for id := range m.removedrepositories {
		ids = append(ids, id)
	}
	return
}

// RepositoriesIDs returns the "repositories" edge IDs in the mutation.
func (m *TeamsMutation) RepositoriesIDs() (ids []string) {
	for id := range m.repositories {
		ids = append(ids, id)
	}
	return
}

// ResetRepositories resets all changes to the "repositories" edge.
func (m *TeamsMutation) ResetRepositories() {
	m.repositories = nil
	m.clearedrepositories = false
	m.removedrepositories = nil
}

// AddBugIDs adds the "bugs" edge to the Bugs entity by ids.
func (m *TeamsMutation) AddBugIDs(ids ...uuid.UUID) {
	if m.bugs == nil {
		m.bugs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bugs[ids[i]] = struct{}{}
	}
}

// ClearBugs clears the "bugs" edge to the Bugs entity.
func (m *TeamsMutation) ClearBugs() {
	m.clearedbugs = true
}

// BugsCleared reports if the "bugs" edge to the Bugs entity was cleared.
func (m *TeamsMutation) BugsCleared() bool {
	return m.clearedbugs
}

// RemoveBugIDs removes the "bugs" edge to the Bugs entity by IDs.
func (m *TeamsMutation) RemoveBugIDs(ids ...uuid.UUID) {
	if m.removedbugs == nil {
		m.removedbugs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bugs, ids[i])
		m.removedbugs[ids[i]] = struct{}{}
	}
}

// RemovedBugs returns the removed IDs of the "bugs" edge to the Bugs entity.
func (m *TeamsMutation) RemovedBugsIDs() (ids []uuid.UUID) {
	for id := range m.removedbugs {
		ids = append(ids, id)
	}
	return
}

// BugsIDs returns the "bugs" edge IDs in the mutation.
func (m *TeamsMutation) BugsIDs() (ids []uuid.UUID) {
	for id := range m.bugs {
		ids = append(ids, id)
	}
	return
}

// ResetBugs resets all changes to the "bugs" edge.
func (m *TeamsMutation) ResetBugs() {
	m.bugs = nil
	m.clearedbugs = false
	m.removedbugs = nil
}

// AddFailureIDs adds the "failures" edge to the Failure entity by ids.
func (m *TeamsMutation) AddFailureIDs(ids ...uuid.UUID) {
	if m.failures == nil {
		m.failures = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.failures[ids[i]] = struct{}{}
	}
}

// ClearFailures clears the "failures" edge to the Failure entity.
func (m *TeamsMutation) ClearFailures() {
	m.clearedfailures = true
}

// FailuresCleared reports if the "failures" edge to the Failure entity was cleared.
func (m *TeamsMutation) FailuresCleared() bool {
	return m.clearedfailures
}

// RemoveFailureIDs removes the "failures" edge to the Failure entity by IDs.
func (m *TeamsMutation) RemoveFailureIDs(ids ...uuid.UUID) {
	if m.removedfailures == nil {
		m.removedfailures = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.failures, ids[i])
		m.removedfailures[ids[i]] = struct{}{}
	}
}

// RemovedFailures returns the removed IDs of the "failures" edge to the Failure entity.
func (m *TeamsMutation) RemovedFailuresIDs() (ids []uuid.UUID) {
	for id := range m.removedfailures {
		ids = append(ids, id)
	}
	return
}

// FailuresIDs returns the "failures" edge IDs in the mutation.
func (m *TeamsMutation) FailuresIDs() (ids []uuid.UUID) {
	for id := range m.failures {
		ids = append(ids, id)
	}
	return
}

// ResetFailures resets all changes to the "failures" edge.
func (m *TeamsMutation) ResetFailures() {
	m.failures = nil
	m.clearedfailures = false
	m.removedfailures = nil
}

// Where appends a list predicates to the TeamsMutation builder.
func (m *TeamsMutation) Where(ps ...predicate.Teams) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Teams, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Teams).
func (m *TeamsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.team_name != nil {
		fields = append(fields, teams.FieldTeamName)
	}
	if m.description != nil {
		fields = append(fields, teams.FieldDescription)
	}
	if m.jira_keys != nil {
		fields = append(fields, teams.FieldJiraKeys)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teams.FieldTeamName:
		return m.TeamName()
	case teams.FieldDescription:
		return m.Description()
	case teams.FieldJiraKeys:
		return m.JiraKeys()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teams.FieldTeamName:
		return m.OldTeamName(ctx)
	case teams.FieldDescription:
		return m.OldDescription(ctx)
	case teams.FieldJiraKeys:
		return m.OldJiraKeys(ctx)
	}
	return nil, fmt.Errorf("unknown Teams field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teams.FieldTeamName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamName(v)
		return nil
	case teams.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case teams.FieldJiraKeys:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJiraKeys(v)
		return nil
	}
	return fmt.Errorf("unknown Teams field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Teams numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Teams nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamsMutation) ResetField(name string) error {
	switch name {
	case teams.FieldTeamName:
		m.ResetTeamName()
		return nil
	case teams.FieldDescription:
		m.ResetDescription()
		return nil
	case teams.FieldJiraKeys:
		m.ResetJiraKeys()
		return nil
	}
	return fmt.Errorf("unknown Teams field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamsMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.repositories != nil {
		edges = append(edges, teams.EdgeRepositories)
	}
	if m.bugs != nil {
		edges = append(edges, teams.EdgeBugs)
	}
	if m.failures != nil {
		edges = append(edges, teams.EdgeFailures)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teams.EdgeRepositories:
		ids := make([]ent.Value, 0, len(m.repositories))
		for id := range m.repositories {
			ids = append(ids, id)
		}
		return ids
	case teams.EdgeBugs:
		ids := make([]ent.Value, 0, len(m.bugs))
		for id := range m.bugs {
			ids = append(ids, id)
		}
		return ids
	case teams.EdgeFailures:
		ids := make([]ent.Value, 0, len(m.failures))
		for id := range m.failures {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrepositories != nil {
		edges = append(edges, teams.EdgeRepositories)
	}
	if m.removedbugs != nil {
		edges = append(edges, teams.EdgeBugs)
	}
	if m.removedfailures != nil {
		edges = append(edges, teams.EdgeFailures)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case teams.EdgeRepositories:
		ids := make([]ent.Value, 0, len(m.removedrepositories))
		for id := range m.removedrepositories {
			ids = append(ids, id)
		}
		return ids
	case teams.EdgeBugs:
		ids := make([]ent.Value, 0, len(m.removedbugs))
		for id := range m.removedbugs {
			ids = append(ids, id)
		}
		return ids
	case teams.EdgeFailures:
		ids := make([]ent.Value, 0, len(m.removedfailures))
		for id := range m.removedfailures {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrepositories {
		edges = append(edges, teams.EdgeRepositories)
	}
	if m.clearedbugs {
		edges = append(edges, teams.EdgeBugs)
	}
	if m.clearedfailures {
		edges = append(edges, teams.EdgeFailures)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamsMutation) EdgeCleared(name string) bool {
	switch name {
	case teams.EdgeRepositories:
		return m.clearedrepositories
	case teams.EdgeBugs:
		return m.clearedbugs
	case teams.EdgeFailures:
		return m.clearedfailures
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamsMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Teams unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamsMutation) ResetEdge(name string) error {
	switch name {
	case teams.EdgeRepositories:
		m.ResetRepositories()
		return nil
	case teams.EdgeBugs:
		m.ResetBugs()
		return nil
	case teams.EdgeFailures:
		m.ResetFailures()
		return nil
	}
	return fmt.Errorf("unknown Teams edge %s", name)
}

// WorkflowsMutation represents an operation that mutates the Workflows nodes in the graph.
type WorkflowsMutation struct {
	config
	op               Op
	typ              string
	id               *int
	workflow_id      *uuid.UUID
	workflow_name    *string
	badge_url        *string
	html_url         *string
	job_url          *string
	state            *string
	clearedFields    map[string]struct{}
	workflows        *string
	clearedworkflows bool
	done             bool
	oldValue         func(context.Context) (*Workflows, error)
	predicates       []predicate.Workflows
}

var _ ent.Mutation = (*WorkflowsMutation)(nil)

// workflowsOption allows management of the mutation configuration using functional options.
type workflowsOption func(*WorkflowsMutation)

// newWorkflowsMutation creates new mutation for the Workflows entity.
func newWorkflowsMutation(c config, op Op, opts ...workflowsOption) *WorkflowsMutation {
	m := &WorkflowsMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflows,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowsID sets the ID field of the mutation.
func withWorkflowsID(id int) workflowsOption {
	return func(m *WorkflowsMutation) {
		var (
			err   error
			once  sync.Once
			value *Workflows
		)
		m.oldValue = func(ctx context.Context) (*Workflows, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workflows.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflows sets the old Workflows of the mutation.
func withWorkflows(node *Workflows) workflowsOption {
	return func(m *WorkflowsMutation) {
		m.oldValue = func(context.Context) (*Workflows, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workflows.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkflowID sets the "workflow_id" field.
func (m *WorkflowsMutation) SetWorkflowID(u uuid.UUID) {
	m.workflow_id = &u
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *WorkflowsMutation) WorkflowID() (r uuid.UUID, exists bool) {
	v := m.workflow_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the Workflows entity.
// If the Workflows object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowsMutation) OldWorkflowID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *WorkflowsMutation) ResetWorkflowID() {
	m.workflow_id = nil
}

// SetWorkflowName sets the "workflow_name" field.
func (m *WorkflowsMutation) SetWorkflowName(s string) {
	m.workflow_name = &s
}

// WorkflowName returns the value of the "workflow_name" field in the mutation.
func (m *WorkflowsMutation) WorkflowName() (r string, exists bool) {
	v := m.workflow_name
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowName returns the old "workflow_name" field's value of the Workflows entity.
// If the Workflows object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowsMutation) OldWorkflowName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowName: %w", err)
	}
	return oldValue.WorkflowName, nil
}

// ResetWorkflowName resets all changes to the "workflow_name" field.
func (m *WorkflowsMutation) ResetWorkflowName() {
	m.workflow_name = nil
}

// SetBadgeURL sets the "badge_url" field.
func (m *WorkflowsMutation) SetBadgeURL(s string) {
	m.badge_url = &s
}

// BadgeURL returns the value of the "badge_url" field in the mutation.
func (m *WorkflowsMutation) BadgeURL() (r string, exists bool) {
	v := m.badge_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBadgeURL returns the old "badge_url" field's value of the Workflows entity.
// If the Workflows object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowsMutation) OldBadgeURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBadgeURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBadgeURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBadgeURL: %w", err)
	}
	return oldValue.BadgeURL, nil
}

// ResetBadgeURL resets all changes to the "badge_url" field.
func (m *WorkflowsMutation) ResetBadgeURL() {
	m.badge_url = nil
}

// SetHTMLURL sets the "html_url" field.
func (m *WorkflowsMutation) SetHTMLURL(s string) {
	m.html_url = &s
}

// HTMLURL returns the value of the "html_url" field in the mutation.
func (m *WorkflowsMutation) HTMLURL() (r string, exists bool) {
	v := m.html_url
	if v == nil {
		return
	}
	return *v, true
}

// OldHTMLURL returns the old "html_url" field's value of the Workflows entity.
// If the Workflows object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowsMutation) OldHTMLURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTMLURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTMLURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTMLURL: %w", err)
	}
	return oldValue.HTMLURL, nil
}

// ResetHTMLURL resets all changes to the "html_url" field.
func (m *WorkflowsMutation) ResetHTMLURL() {
	m.html_url = nil
}

// SetJobURL sets the "job_url" field.
func (m *WorkflowsMutation) SetJobURL(s string) {
	m.job_url = &s
}

// JobURL returns the value of the "job_url" field in the mutation.
func (m *WorkflowsMutation) JobURL() (r string, exists bool) {
	v := m.job_url
	if v == nil {
		return
	}
	return *v, true
}

// OldJobURL returns the old "job_url" field's value of the Workflows entity.
// If the Workflows object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowsMutation) OldJobURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobURL: %w", err)
	}
	return oldValue.JobURL, nil
}

// ResetJobURL resets all changes to the "job_url" field.
func (m *WorkflowsMutation) ResetJobURL() {
	m.job_url = nil
}

// SetState sets the "state" field.
func (m *WorkflowsMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *WorkflowsMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Workflows entity.
// If the Workflows object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowsMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *WorkflowsMutation) ResetState() {
	m.state = nil
}

// SetWorkflowsID sets the "workflows" edge to the Repository entity by id.
func (m *WorkflowsMutation) SetWorkflowsID(id string) {
	m.workflows = &id
}

// ClearWorkflows clears the "workflows" edge to the Repository entity.
func (m *WorkflowsMutation) ClearWorkflows() {
	m.clearedworkflows = true
}

// WorkflowsCleared reports if the "workflows" edge to the Repository entity was cleared.
func (m *WorkflowsMutation) WorkflowsCleared() bool {
	return m.clearedworkflows
}

// WorkflowsID returns the "workflows" edge ID in the mutation.
func (m *WorkflowsMutation) WorkflowsID() (id string, exists bool) {
	if m.workflows != nil {
		return *m.workflows, true
	}
	return
}

// WorkflowsIDs returns the "workflows" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowsID instead. It exists only for internal usage by the builders.
func (m *WorkflowsMutation) WorkflowsIDs() (ids []string) {
	if id := m.workflows; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflows resets all changes to the "workflows" edge.
func (m *WorkflowsMutation) ResetWorkflows() {
	m.workflows = nil
	m.clearedworkflows = false
}

// Where appends a list predicates to the WorkflowsMutation builder.
func (m *WorkflowsMutation) Where(ps ...predicate.Workflows) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Workflows, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Workflows).
func (m *WorkflowsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.workflow_id != nil {
		fields = append(fields, workflows.FieldWorkflowID)
	}
	if m.workflow_name != nil {
		fields = append(fields, workflows.FieldWorkflowName)
	}
	if m.badge_url != nil {
		fields = append(fields, workflows.FieldBadgeURL)
	}
	if m.html_url != nil {
		fields = append(fields, workflows.FieldHTMLURL)
	}
	if m.job_url != nil {
		fields = append(fields, workflows.FieldJobURL)
	}
	if m.state != nil {
		fields = append(fields, workflows.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflows.FieldWorkflowID:
		return m.WorkflowID()
	case workflows.FieldWorkflowName:
		return m.WorkflowName()
	case workflows.FieldBadgeURL:
		return m.BadgeURL()
	case workflows.FieldHTMLURL:
		return m.HTMLURL()
	case workflows.FieldJobURL:
		return m.JobURL()
	case workflows.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflows.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case workflows.FieldWorkflowName:
		return m.OldWorkflowName(ctx)
	case workflows.FieldBadgeURL:
		return m.OldBadgeURL(ctx)
	case workflows.FieldHTMLURL:
		return m.OldHTMLURL(ctx)
	case workflows.FieldJobURL:
		return m.OldJobURL(ctx)
	case workflows.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown Workflows field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflows.FieldWorkflowID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case workflows.FieldWorkflowName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowName(v)
		return nil
	case workflows.FieldBadgeURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBadgeURL(v)
		return nil
	case workflows.FieldHTMLURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTMLURL(v)
		return nil
	case workflows.FieldJobURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobURL(v)
		return nil
	case workflows.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown Workflows field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Workflows numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Workflows nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowsMutation) ResetField(name string) error {
	switch name {
	case workflows.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case workflows.FieldWorkflowName:
		m.ResetWorkflowName()
		return nil
	case workflows.FieldBadgeURL:
		m.ResetBadgeURL()
		return nil
	case workflows.FieldHTMLURL:
		m.ResetHTMLURL()
		return nil
	case workflows.FieldJobURL:
		m.ResetJobURL()
		return nil
	case workflows.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown Workflows field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workflows != nil {
		edges = append(edges, workflows.EdgeWorkflows)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflows.EdgeWorkflows:
		if id := m.workflows; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkflows {
		edges = append(edges, workflows.EdgeWorkflows)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowsMutation) EdgeCleared(name string) bool {
	switch name {
	case workflows.EdgeWorkflows:
		return m.clearedworkflows
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowsMutation) ClearEdge(name string) error {
	switch name {
	case workflows.EdgeWorkflows:
		m.ClearWorkflows()
		return nil
	}
	return fmt.Errorf("unknown Workflows unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowsMutation) ResetEdge(name string) error {
	switch name {
	case workflows.EdgeWorkflows:
		m.ResetWorkflows()
		return nil
	}
	return fmt.Errorf("unknown Workflows edge %s", name)
}
